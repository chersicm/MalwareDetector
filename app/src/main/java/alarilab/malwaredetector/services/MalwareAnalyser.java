package alarilab.malwaredetector.services;

import android.os.Message;
import android.util.Log;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import alarilab.malwaredetector.core.AppData;
import alarilab.malwaredetector.core.DeviceInfos;
import alarilab.malwaredetector.core.resources.AppProcess;
import alarilab.malwaredetector.detection.ApplicationEvaluator;
import alarilab.malwaredetector.detection.RecordEvaluator;
import alarilab.malwaredetector.core.resources.ResourceUsage;
import alarilab.malwaredetector.core.LooperThread;
import alarilab.malwaredetector.shared.Signal;
import alarilab.malwaredetector.shared.StatisticsData;
import alarilab.malwaredetector.utility.logger.L;

/**
 * Created by vidal on 01.03.15.
 */
public class MalwareAnalyser extends LooperThread {

    private static MalwareAnalyser m_instance = null;

    private List<AppProcess> m_processes = null;
    private final Object m_listProcMutex = new Object();

    private int malwareCount;
    private int trustedCount;

    private long timerStart;
    private final long TIME_LIMIT = 300000; // time limit in milliseconds (5 minutes)

    private RecordEvaluator evaluator = new RecordEvaluator();
    // map pid --> evaluator : pid should not change for consistency
    private HashMap<Integer, ApplicationEvaluator> evals = new HashMap<>();
    private boolean malwareFound = false;

    private MalwareAnalyser() {
        super(AppData.MALWAREANALYSERSERVICE, "Malware_Analyser");
    }

    public static synchronized MalwareAnalyser getInstance() {
        if (m_instance == null)
            m_instance = new MalwareAnalyser();
        return m_instance;
    }

    public static boolean isNull() {
        return m_instance == null;
    }

    @Override
    protected void onStart() {
        // wait for DeviceMonitor to be started
        while (DeviceMonitor.isNull()) ;
        timerStart = System.currentTimeMillis();
    }

    @Override
    protected void onQuit() {
    }

    @Override
    protected void removeHandledMessages() {
    }

    private void printTimeout() {
        long elapsed = System.currentTimeMillis() - timerStart;
        Log.d("handleMessage", "received timeout at " + elapsed / 1000 + " seconds");
    }

    @Override
    public boolean handleMessage(Message msg) {
        //To avoid memory leaks, Remember to remove any pending handled messages in the function removeHandledMessages().
        //This function is called when the service is stopped.
        boolean handled = false;
        switch (msg.what) {
            case Signal.MALWARE_ANALYSER_TIMEOUT:
//                printTimeout();
                synchronized (m_listProcMutex) {
                    m_processes = new ArrayList<>((List<AppProcess>) msg.obj);
                    runDetection();
                }
                handled = true;
                break;
            default:
                L.w("Message with id: " + msg.what + " not handled!");
        }

        if (handled)
            m_Handler.removeMessages(msg.what);

        return handled;
    }

    private int recordLevel(Number[] record, int pid) {
        return evaluator.evaluate(record, pid);
    }

    private boolean slidingWindowFull(ApplicationEvaluator eval, int record_eval) {
        return eval.addCheckWindowFull(record_eval);
    }

    private boolean applicationLevel(ApplicationEvaluator eval) {
        return eval.evaluate();
    }

    private void runDetection() {
        DeviceInfos deviceInfos = DeviceMonitor.getInstance().getDeviceInfos();
        if (deviceInfos == null) {
            Log.e("runDetection: error", "null object reference: deviceInfos");
            return;
        }
        List<StatisticsData> CPUall = deviceInfos.getResourceUsageInfos(ResourceUsage.RESOURCETYPE.CPU);
        List<StatisticsData> RAMall = deviceInfos.getResourceUsageInfos(ResourceUsage.RESOURCETYPE.RAM);
        if (CPUall.size() != RAMall.size()) {
            Log.e("runDetection: error", "number of CPU and RAM records must be the same");
            return;
        }

        malwareCount = 0;
        trustedCount = 0;
        boolean malwareFoundNow = false;

        // run detection algorithm for every active application
        for (int i = 0; i < RAMall.size(); i++) {
            StatisticsData CPU = CPUall.get(i);
            StatisticsData RAM = RAMall.get(i);

            double CPUtotal = new Float(CPU.m_percentage).doubleValue();
            RAM.addCPU(CPUtotal); // record now contains all features

            int pid = RAM.pid();
            int recordClass = recordLevel(RAM.getRecord(), pid); // evaluation of a record
            RAM.storeRecord(recordClass); // store record in DB

//            RAM.dumpRecord();

            // add evaluators if needed
            if (evals.get(pid) == null)
                evals.put(pid, new ApplicationEvaluator(pid));

            ApplicationEvaluator eval = evals.get(pid);

            if (slidingWindowFull(eval, recordClass)) {
                if (applicationLevel(eval)) {
                    long elapsed = (System.currentTimeMillis() - timerStart) / 1000;
                    Log.d("MalwareAnalyser", "malware found: " + pid + " [elapsed time -> " + elapsed + " seconds]");
                    malwareFoundNow = true;
                    malwareFound = markProcessAsMalware(pid);
                    if (!malwareFound) {
                        Log.e("runDetection: error", "failed to mark process as malware");
                        return;
                    }
                } else {
                    markProcessAsTrusted(pid);
                }
            }
        }

        if (malwareFoundNow) {
            notifyUi(); // notify the GUI
        }

        // notify timeout
        long elapsed = System.currentTimeMillis() - timerStart;
        if (elapsed >= TIME_LIMIT && !malwareFound) {
            elapsed /= 1000;
            Log.d("MalwareAnalyser", "No Malware Timeout [elapsed time -> " + elapsed + " seconds]");
            trustedCount = RAMall.size();
            notifyTimeoutUi();
            timerStart = System.currentTimeMillis(); // reset timer
        }
    }

    private void notifyUi() {
        if (m_processes != null) {
            Signal sig = AppData.obtainSignal(AppData.MAINACTIVITYSERVICE);
            if (sig != null) {
                sig.m_signalId = Signal.MALWARE_LIST_UPDATED;
                sig.m_obj = new ArrayList<>(m_processes);
                sig.m_arg1 = malwareCount;
                sig.m_arg2 = trustedCount;
                sig.emit();
            }
        }
    }

    private void notifyTimeoutUi() {
        Signal sig = AppData.obtainSignal(AppData.MAINACTIVITYSERVICE);
        if (sig != null) {
            sig.m_signalId = Signal.MALWARE_TIMEOUT;
            sig.m_arg1 = malwareCount;
            sig.m_arg2 = trustedCount;
            sig.emit();
        }
    }

    private boolean markProcessAsMalware(int pid) {
        for (AppProcess proc : m_processes) {
            if (proc.pid() == pid) {
                proc.setMalware(true);
                malwareCount++;
                return true;
            }
        }
        return false;
    }

    private boolean markProcessAsTrusted(int pid) {
        for (AppProcess proc : m_processes) {
            if (proc.pid() == pid) {
                proc.setMalware(false);
                trustedCount++;
                return true;
            }
        }
        return false;
    }

    @Override
    public synchronized boolean stopService() {
        m_instance = null; //java does not allow to restart a thread already started even if it was stopped!
        return super.stopService();
    }
}
