package alarilab.malwaredetector.services;

import android.os.Message;
import android.util.Log;
import android.util.Pair;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

import alarilab.malwaredetector.core.AppData;
import alarilab.malwaredetector.core.LooperThread;
import alarilab.malwaredetector.core.resources.AppProcess;
import alarilab.malwaredetector.database.tables.SysCallsStatisticsTable;
import alarilab.malwaredetector.shared.Signal;
import alarilab.malwaredetector.shared.StatisticsData;
import alarilab.malwaredetector.utility.logger.L;

/**
* Created by vidal on 27.03.15.
*/
class SysCallsStatistics extends LooperThread {
    private SysCallsMonitor sysCallsMonitor;
    protected Timer m_samplingTimer = null;
    private Map<Integer, ArrayList<StatisticsData>> m_lDataPerPid = null;
    private long m_samplingTime = 1000; // considering the second let's samples each 10s
    private long m_maxSystemDelay = 15000;
    private final Object m_lDataLocker = new Object();
    private Map<Integer, ArrayList<StatisticsData>> m_cachedLDataPerPid = new HashMap<>();

    SysCallsStatistics(SysCallsMonitor sysCallsMonitor) {
        super(AppData.SYSCALLSTATSSERVICE,"SysCalls_Statistics");
        this.sysCallsMonitor = sysCallsMonitor;
    }

    @Override
    protected void onStart() {
        synchronized (m_lDataLocker) {
            if (m_lDataPerPid == null)
                m_lDataPerPid = new HashMap<Integer, ArrayList<StatisticsData>>();
            else
                m_lDataPerPid.clear();
        }

        if (m_samplingTime > 0) {
            if (m_samplingTimer == null)
                m_samplingTimer = new Timer("SysCallsStats_samplingTimerThread", true);
            L.d("Timer Started!");
            m_samplingTimer.schedule(new TimerTask() {
                @Override
                public void run() {
                    makeStatistics();
                }
            }, 3000, m_samplingTime);
        }
    }

    protected void makeStatistics() {

        // merge stats
        synchronized (m_lDataLocker) {
            for (Map.Entry<Integer, ArrayList<StatisticsData>> entry : m_lDataPerPid.entrySet()) {
                ArrayList<StatisticsData> lLastStats = m_cachedLDataPerPid.get(entry.getKey());
                if (lLastStats == null) {
                    m_cachedLDataPerPid.put(entry.getKey(), entry.getValue());
                }
                else {
                    lLastStats.addAll(entry.getValue()); // must keep statistics order
                    entry.getValue().clear();
                }
            }
            m_lDataPerPid.clear();
        }

        // make statistics
        Iterator<Map.Entry<Integer, ArrayList<StatisticsData>>> iterator = m_cachedLDataPerPid.entrySet().iterator();

        while (iterator.hasNext())
        {
            Map.Entry<Integer, ArrayList<StatisticsData>> entry = iterator.next();
            ArrayList<StatisticsData> lLastStats = entry.getValue();

            boolean todel = lLastStats.isEmpty(); // if the statistics is empty we remove it from the list after saving the in db.

            makeStatisticsPerProc(entry.getKey(), entry.getValue(), false);

            if(todel)
                iterator.remove();
        }

    }


    @Override
    public void removeHandledMessages() {
        m_Handler.removeMessages(Signal.NEW_SYSCALLS_AVAILABLE);
        m_Handler.removeMessages(Signal.PROCESS_LIST_UPDATED);
    }

    @Override
    public boolean handleMessage(Message msg) {
        //To avoid memory leaks, Remember to remove any pending handled messages in the function removeHandledMessages().
        //This function is called when the service is stopped.
        boolean handled = false;

        switch (msg.what) {
            case Signal.NEW_SYSCALLS_AVAILABLE: {
                processNewStats(((StatisticsData) msg.obj));
                handled = true;
                break;
            }
            case Signal.PROCESS_LIST_UPDATED: {
                Log.d(m_serviceName, "Signal.PROCESS_LIST_UPDATED");
                updateProcessList((List<AppProcess>) msg.obj);
                handled = true;
            }
            break;
            default:
                L.w("Message with id: " + msg.what + " not handled!");
        }

        return handled;
    }

    void updateProcessList(List<AppProcess> lProc) {

        if (false) { //obsolete! the makeStatistics and processNewStats functions almost do the same job!
            // if a process does not generate any syscalls between 2 samplings, a statistic with num_syscall equal 0 will be saved
            // in the db and its instance in the array we be destroyed (see makeStatistics and makeStatisticsPerProc).
            // if we receive a syscall from an unknown process, then a new instance for the pid will
            // be created. (see processNewStats).
            synchronized (m_lDataLocker) {
                Iterator<Map.Entry<Integer, ArrayList<StatisticsData>>> iter = m_lDataPerPid.entrySet().iterator();
                while (iter.hasNext()) {
                    Map.Entry<Integer, ArrayList<StatisticsData>> entry = iter.next();

                    int pid = entry.getKey();
                    boolean found = false;

                    //let's search if an entry of this process already exists in lProc
                    for (AppProcess aLProc : lProc) {
                        if (aLProc.pid() == pid) {
                            found = true;
                            iter.remove(); // an entry already exists, let's remove it from the lProc list
                            break;
                        }
                    }

                    if (!found) {
                        //the process was kill or deselected,
                        // let's save its statistics before removing any reference to it.
                        ArrayList<StatisticsData> arr = entry.getValue();
                        if (arr != null) {
                            makeStatisticsPerProc(entry.getKey(), entry.getValue(), true);
                        }
                        iter.remove();
                    }
                }

                //add in m_lDataPerPid list the remained processes found in lProc list.
                for (AppProcess proc : lProc) {
                    ArrayList<StatisticsData> arr = new ArrayList<>();
                    m_lDataPerPid.put(proc.pid(), arr); // add an empty array list. It will be populated later after receiving strace logs
                }
            }
        }
    }

    void processNewStats(StatisticsData statData) {
        if (statData != null && statData.isValid()) {
            int key = statData.pid();
            synchronized (m_lDataLocker) {
                ArrayList<StatisticsData> lLastStats = m_lDataPerPid.get(key);

                boolean added = false;

                if (lLastStats != null) {
                    added = true;
                    lLastStats.add(statData);
                }

                //we may received system calls of children processes and may not exist in m_currTracedProc
                if (!added /*&& m_currTacedProc != null && m_currTacedProc.contains(String.valueOf(key))*/) {
                    ArrayList<StatisticsData> arr = new ArrayList<>();
                    arr.add(statData);
                    m_lDataPerPid.put(key, arr);
                }
            }
        }
        else {
            L.e("Data not valid!");
        }
    }

    @Override
    public synchronized boolean stopService() {

        if (m_samplingTimer != null) {
            m_samplingTimer.cancel();
            m_samplingTimer = null;
        }

        boolean ret = super.stopService();
        synchronized (m_lDataLocker) {
            if (m_lDataPerPid != null) {
                m_lDataPerPid.clear();
                m_lDataPerPid = null;
            }
        }
        return ret;
    }

    private void makeStatisticsPerProc(int pid, ArrayList<StatisticsData> lLastStats, boolean force) {
        //I'm assuming that all calls are already ordered by timestamp.
        //So, the least recent call is the first in the list and the most recent one is the last
        List<StatisticsData> lstats1 = new ArrayList<>();

        StatisticsData data;
        if (lLastStats != null && !lLastStats.isEmpty()) {
            //first method: we just count the number of calls each sampling time
            if (false) {
                StatisticsData lastData = lLastStats.get(lLastStats.size() - 1);
                data = new StatisticsData(pid);
                data.m_tableName = SysCallsStatisticsTable.TABLE_NAME;
                data.m_timeStamp = (new Date()).getTime();
                data.m_numCallsPerSec = lLastStats.size();
                lstats1.add(data);
                lLastStats.clear();
            }
            else {
                //second method: we counts the number of system calls
                // using as reference the effective timestamp of the call

                // we want to count the number of syscalls in a second.
                // By dividing and casting we're ignoring the millis sec part
                long currTimeStamp = (new Date()).getTime() / 1000;
                long timeStampRefInSec = lLastStats.get(0).m_timeStamp / 1000;

                ArrayList< Pair<Long,Integer> > stats = new ArrayList<>();
                ArrayList<StatisticsData> toRem = new ArrayList<>();
                ArrayList<StatisticsData> tempToRem = new ArrayList<>();

                for (StatisticsData statdata : lLastStats) {
                    long statTimeStampInSec = statdata.m_timeStamp / 1000;
                    if (statTimeStampInSec <= timeStampRefInSec) {

                        if (statTimeStampInSec < timeStampRefInSec)
                            L.w("This list is not ordered as by assumption");

                        tempToRem.add(statdata);
                    }
                    else if (statTimeStampInSec > timeStampRefInSec) {
                        stats.add(new Pair<>(timeStampRefInSec, tempToRem.size()));

                        timeStampRefInSec = statTimeStampInSec; // update reference time stamp
                        toRem.addAll(tempToRem);//caches the statistics data to remove
                        tempToRem.clear(); // clear the temp array for new iteration
                        tempToRem.add(statdata); // caches the current statdata
                    }

                }

                if (!tempToRem.isEmpty()) {
                    long lastCreationTime = tempToRem.get(tempToRem.size()-1).m_creationTimeStamp;
                    if (((currTimeStamp - lastCreationTime) >= (m_maxSystemDelay / 1000)) || force) {
                        //Here, we're trying to take into account the fact that, the overall system may be heavy and may not be able to process all
                        //system calls log in time. Supposing m_maxSystemDelay is the max delay time the system can reach in such case,
                        // we wait m_maxSystemDelay (this function is called at each sampling time) before saving the statistics in the database.
                        stats.add(new Pair<>(timeStampRefInSec, tempToRem.size()));
                        toRem.addAll(tempToRem);//caches the statistics data to remove
                    }
                    tempToRem.clear();
                }

                //remove from input list statistics data already counted
                for (StatisticsData tmpData : toRem) {
                    lLastStats.remove(tmpData);
                }
                toRem.clear();

                //save statistics in the db

                for (Pair<Long,Integer> entry : stats) {
                    StatisticsData tmpdata = new StatisticsData(pid);
                    tmpdata.m_tableName = SysCallsStatisticsTable.TABLE_NAME;
                    tmpdata.m_timeStamp = entry.first * 1000; // the timestamp in Pair was created in sec
                    tmpdata.m_numCallsPerSec = entry.second;
                    lstats1.add(tmpdata);
                    tmpdata.dump();
                }
                stats.clear();

               /* if(!lstats1.isEmpty() && sysCallsMonitor != null) {
                    //sysCallsMonitor.addNewListStatisticsData(lstats1);
                    DbHandler.getInstance().saveData(lstats1, true);
                }*/

                if (force)
                    lLastStats.clear();

                // The third method: we counts the number of system calls
                // by doing an average

               /*NOT COMPLETED
               long timeStampFirstElt = 0, timeStampLastElt = 0;
               Calculate the number of calls made after 1 sec

               float numCalls = 0;
               timeStampFirstElt = lLastStats.get(0).m_timeStamp;
               timeStampLastElt = lastData.m_timeStamp;
               long refTime = 0;


                This stat is based on the effective timestamp of calls returned by strace
                if((refTime = (timeStampLastElt - timeStampFirstElt)) >= 1)
                {
                    data = new StatisticsData(pid);
                    data.m_tableName = SysCallsStatisticsTable.TABLE_NAME;
                    data.m_timeStamp = (new Date()).getTime();
                    //get the average
                    data.m_numCallsPerSec = (int)lLastStats.size()/refTime;


                }
                else if(lLastStats.size() == 1){
                    data = new StatisticsData(pid);
                    data.m_tableName = SysCallsStatisticsTable.TABLE_NAME;
                    data.m_timeStamp = (new Date()).getTime();
                    //get the average
                    data.m_numCallsPerSec = 1;
                }
                lLastStats.clear();
                */

            }

        }
        else {
            data = new StatisticsData(pid);
            data.m_tableName = SysCallsStatisticsTable.TABLE_NAME;
            data.m_timeStamp = (new Date()).getTime();
            data.m_numCallsPerSec = 0;
            lstats1.add(data);
        }

        if (!lstats1.isEmpty())
            DbHandler.getInstance().saveData(lstats1, true);
            //sysCallsMonitor.addNewStatisticsData(data);

    }
}
