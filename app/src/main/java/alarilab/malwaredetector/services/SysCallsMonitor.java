package alarilab.malwaredetector.services;

import android.os.Message;

import java.io.DataOutputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Pattern;

import alarilab.malwaredetector.core.AppData;
import alarilab.malwaredetector.core.LooperThread;
import alarilab.malwaredetector.core.resources.AppProcess;
import alarilab.malwaredetector.database.tables.SysCallsTable;
import alarilab.malwaredetector.shared.Signal;
import alarilab.malwaredetector.shared.StatisticsData;
import alarilab.malwaredetector.utility.Test.SyscallsTester;
import alarilab.malwaredetector.utility.Utils;
import alarilab.malwaredetector.utility.logger.L;


public class SysCallsMonitor extends LooperThread {

    private static SysCallsMonitor m_instance = new SysCallsMonitor();
    private java.lang.Process m_tracerProcess = null;
    private SysCallsStatistics m_sysCallsStats = null;
    private List<StatisticsData> l_statsData = new ArrayList<StatisticsData>();
    private List<String> m_currTacedProc = null;
    private Object m_tracerLocker = new Object();
    private Object m_lStatsDataLocker = new Object();

    private SyscallsTester m_sysCallTester = SyscallsTester.DEBUG ? new SyscallsTester() : null; // this is useful only for debug purpose.

    private SysCallsMonitor() {
        super(AppData.SYSCALLSSERVICE, "SysCall_Monitor");
        if (SyscallsTester.DEBUG)
            m_currTacedProc = m_sysCallTester.getTracedProc();
    }

    public static synchronized SysCallsMonitor getInstance() {
        if (m_instance == null)
            m_instance = new SysCallsMonitor();
        return m_instance;
    }

    public static boolean isNull() {
        return m_instance == null;
    }

    @Override
    protected void onStart() {
        L.d(m_serviceName + " started!");

        Signal sig =  AppData.obtainSignal(AppData.DEVICEMONITORSERVICE);//new Utils.Signal(DeviceMonitor.getInstance().handler());
        if(sig != null) {
            sig.m_signalId = Signal.UPDATE_SYSCALL_MONITOR_PROC_LIST;
            sig.emit();
        }

        if (AppData.getInstance().sysCallsStatEnabled()) {
            manageSysCallsStatsService(true);
        }
        else {
            L.w("SysCalls Service not enabled!");
        }
    }

    private synchronized void manageSysCallsStatsService(boolean enabled) {

        if (m_sysCallsStats == null && enabled)
            m_sysCallsStats = new SysCallsStatistics(this);

        if (m_sysCallsStats != null) {
            if (enabled) {
                try {
                    m_sysCallsStats.startService();
                } catch (StartingException e) {
                    e.printStackTrace();
                    L.e("Could not able to the SysCallsStatistics service!");
                }
            }
            else {
                m_sysCallsStats.stopService();
                m_sysCallsStats = new SysCallsStatistics(this); // once we stop a java thread, we cannot reuse it anymore, we have to initialise a new instance!
            }
        }
        else {
            L.e("The Syscalls Service is null!");
        }

    }
    @Override
    protected void onQuit() {

        if(m_Handler.hasMessages(Signal.NEW_SYSCALLS_AVAILABLE))
            L.w("There're still some systems call log in the handler queue! They will be removed!");

        if (m_currTacedProc != null) {
            m_currTacedProc.clear();
            m_currTacedProc = null;
        }

        if (m_sysCallTester != null) {
            m_sysCallTester.clear();
            m_sysCallTester = null;
        }
    }

    @Override
    protected void removeHandledMessages() {
        m_Handler.removeMessages(Signal.NEW_SYSCALLS_AVAILABLE);
        m_Handler.removeMessages(Signal.MONITOR_CONFIG_CHANGED);
    }
    @Override
    public boolean handleMessage(Message msg) {
        //To avoid memory leaks, Remember to remove any pending handled messages in the function removeHandledMessages().
        //This function is called when the service is stopped.
        boolean handled = false;
        switch (msg.what) {
            case Signal.NEW_SYSCALLS_AVAILABLE: {
                processTraceLine((StatisticsData) msg.obj);
                handled = true;
                break;
            }
            case Signal.MONITOR_CONFIG_CHANGED: {
                boolean enabled = AppData.getInstance().sysCallsStatEnabled();
                manageSysCallsStatsService(enabled);

                handled = true;
            }
            default:
                L.w("Message with id: " + msg.what + " not handled!");
        }

        return handled;
    }

    @Override
    public synchronized boolean stopService() {
        m_instance = null;

        stopTracing();

        if (m_sysCallsStats != null) {
            m_sysCallsStats.stopService();
            m_sysCallsStats = null;
        }

        return super.stopService();
    }

    private void processTraceLine(StatisticsData data) {

        //check if it's a valid trace line
        //StatisticsData data;
        //if ((data = convertToStatisticsData(traceLine)) != null) {

        //data.dump();
        //caches this new stats or save it in the Db
        addNewStatisticsData(data);

        if (AppData.getInstance().sysCallsStatEnabled()
                && m_sysCallsStats != null
                && m_sysCallsStats.handler() != null) {
            //redirect this stats to the syscallsStatistics service
            Signal sig = new Signal(m_sysCallsStats.handler());
            sig.m_signalId = Signal.NEW_SYSCALLS_AVAILABLE;
            sig.m_obj = data;
            sig.emit();//Utils.emit(sig);
        }
        else {
            L.w("SysCallStats service not enabled or the message handler is null! skipping its notification phase!");
        }
        /*}
        else {
            L.w("This trace line is not valid: " + traceLine + "\nIgnoring it...");
        }*/
    }
    public void addNewStatisticsData(StatisticsData data) {
         List<StatisticsData> lData = new ArrayList<>();
        lData.add(data);
        addNewListStatisticsData(lData);
        lData.clear();
    }

    public void addNewListStatisticsData(List<StatisticsData> ldata) {

        if (ldata != null && AppData.getInstance().dbHandlerEnabled()) {
            //here, we can cache both statistics (calls and num calls/s) and save them later after a fixed timeout (TODO... maybe!)
            //Now we just save the list in the db. This list will always contains one elt!
            synchronized (m_lStatsDataLocker) {
                l_statsData.addAll(ldata);
                DbHandler.getInstance().saveData(l_statsData, true);
                l_statsData.clear();
            }

        }
        else {
            L.w("The database is not enabled! Ignoring new statistics!");
        }
    }

    private String getTracerCommand(List<String> lPid) {
        StringBuilder builder = new StringBuilder();

        //append options
        builder.append("strace");

        // (-q)suppress messages about attaching and detaching,
        // (-ttt)add the timestamp of system calls,
        // (-v) print some gory details (see strace doc for more infos)
        // (-p) the process pid to trace
        // (-f)attach to all children processes created using a fork. vfork, clone.
        // ( for this reason, we might receive system call log from pid where are not listed in our process list.

        builder.append(" -qtttv");
        for (String pid : lPid) {
            builder.append(" -p");
            builder.append(pid);
        }

        builder.append(" ");

        return builder.toString();
    }

    public synchronized void updateProcList(List<AppProcess> lProc) {

        if (AppData.getInstance().sysCallMonitorEnabled()) {
            // if (AppData.getInstance().isRoot()) {
            if (isRunning()) {
                if (m_Handler != null) {

                    m_Handler.removeCallbacks(new UpdateTracerTask(null)); // remove pending UpdateTracerTask
                    stopTracing(); //force the ongoing UpdateTracerTask to stop immediately

                    //Notify the sysCallsStatServices about changes
                    if (m_sysCallsStats != null
                            && AppData.getInstance().sysCallsStatEnabled()
                            && m_sysCallsStats.isRunning()) {
                        Signal sig = new Signal(m_sysCallsStats.handler());
                        sig.m_signalId = Signal.PROCESS_LIST_UPDATED;
                        sig.m_obj = lProc;
                        sig.emit();//Utils.emit(sig);
                    }

                    List<String> lPid = new ArrayList<String>();
                    for (AppProcess proc : lProc) {
                        lPid.add(Integer.toString(proc.pid()));
                    }

                    if (m_sysCallTester == null)
                        m_Handler.postAtFrontOfQueue(new UpdateTracerTask(lPid));

                }
                else {
                    L.e("No handler found!");
                }
            }
            else {
                L.e("The service " + m_serviceName + " is not running!");
            }
            /*} else {
                L.w("This device is not rooted! Cannot start the System Call Monitor");
            }*/
        }
        else {
            L.w("SysCallsMonitor not enabled!");
        }

    }

    private void stopTracing() {
        L.d(L.START);

        synchronized (m_tracerLocker) {
            if (m_tracerProcess != null) {
                m_tracerProcess.destroy();
                m_tracerProcess = null;
            }
        }

        L.d(L.END);
    }

    private StatisticsData convertToStatisticsData(int procPid,String traceLine) {
        StatisticsData retVal = null;
        if (traceLine != null && !traceLine.isEmpty()) {

            boolean isValid = false;
            long timeStamp = 0;

            //retrieve pid
            // it should be enclosed like this [PID XXXXX]

            if (procPid == -1) {
                StringTokenizer tk1 = new StringTokenizer(traceLine);
                String str1 = "", str2 = "";

                if (tk1.hasMoreTokens()) {
                    str1 = tk1.nextToken();//should be "[PID"
                    if (str1.substring(1).toUpperCase().equals("PID")) {
                        str2 = tk1.nextToken(); //should be "XXXXX]"
                        String pidStr = str2.substring(0, str2.length() - 1); //exclude the last parenthesis
                        if (Utils.isNumeric(pidStr)) {
                            procPid = Integer.valueOf(pidStr);
                        }
                        else {
                            L.e("Invalid trace line! - Non numeric pid [" + str2 + "]");
                        }
                    }
                    else {
                        L.e("Invalid trace line! Unexpected start line [" + str1 + "]");

                    }

                }

                if (procPid > 0) {
                    String pattern = Pattern.quote(str1 + " " + str2);
                    String[] tk3 = traceLine.split(pattern);//here we want to remove the information about the pid
                    if (tk3.length == 2) {
                        traceLine = tk3[1].trim();
                    }

                }
                else {
                    L.e("Invalid Pid [" + procPid + "]!");
                    traceLine = "";
                }

            }


            if (!traceLine.isEmpty() && procPid > 0) {
                //retrieve timestamp
                StringTokenizer st = new StringTokenizer(traceLine);
                String sysCall = "";
                String sysCallTimeStampStr = "";
                while (st.hasMoreTokens()) {
                    String tk = st.nextToken();
                    if (!tk.isEmpty()) {
                        //we just need to process the first token and it should have this format XXXXXXXXXXX.YYYYYY
                        //where the leading part XXXXXXXXXXX represents the time from epoch in seconds
                        //and the last part is in microseconds
                        if (Utils.isNumeric(tk)) {
                            //since the accuracy time of java is in milliseconds,
                            // we convert the timestamp of linux from microseconds to milliseconds
                            timeStamp = (long) (Double.parseDouble(tk) * 1000);
                            isValid = true;
                            sysCall = traceLine.substring(tk.length()).trim();
                            sysCallTimeStampStr = tk;

                        }
                        break;
                    }

                }

                if (isValid) {
                    retVal = new StatisticsData(procPid);
                    retVal.m_tableName = SysCallsTable.TABLE_NAME;
                    retVal.m_timeStamp = timeStamp;
                    retVal.m_sysCallTimeStampStr = sysCallTimeStampStr;
                    if (false) {
                        retVal.m_sysCallStr = traceLine; //system call with timestamp
                    }
                    else {
                        retVal.m_sysCallStr = sysCall; //system call without timestamp
                    }
                }
            }
        }

        return retVal;
    }

    private class TracerReader extends Utils.StreamReader
    {
        private List<String> m_lPid = null;

        public TracerReader(InputStream inStream, List<String> lPid) {
            super(inStream);
            m_lPid = lPid;
        }

        @Override
        public void processLine(String line) {
            L.i(line);
            if (m_Handler != null) { //we should protect accesses to m_handler
                if(m_lPid != null && !m_lPid.isEmpty())
                {
                    int pid = -1;

                    if(m_lPid.size() == 1 && Utils.isNumeric(m_lPid.get(0)))
                        pid = Integer.valueOf(m_lPid.get(0));

                    StatisticsData data = SysCallsMonitor.this.convertToStatisticsData(pid, line);

                    if(data != null) {
                        data.dump();
                        Signal sig = new Signal(m_Handler);
                        sig.m_signalId = Signal.NEW_SYSCALLS_AVAILABLE;
                        sig.m_obj = data;
                        sig.emit();//Utils.emit(sig);
                    }
                }

            }
            else {
                L.e("There is no message handler. This means that the SysCallMonitor was not started or it was stopped without actually stopping its Stream" +
                        "reader.");
            }

        }
    }

    private class UpdateTracerTask implements Runnable {
        private List<String> m_lPid = null;

        UpdateTracerTask(List<String> lPid) {
            m_lPid = lPid;
        }

        @Override
        public void run() {
            m_currTacedProc = m_lPid;
            stopTracing();
            if (!m_lPid.isEmpty()) {
                startTracing();
            }
            else {
                L.d("There is no process to trace!");
            }

        }

        private void startTracing() {
            try {
                String cmd = getTracerCommand(m_lPid);

                synchronized (m_tracerLocker) {

                    if (AppData.getInstance().isRoot())
                        m_tracerProcess = Utils.getSuShell(true);
                    else
                        m_tracerProcess = Utils.getShell(true);

                    if (m_tracerProcess != null) {

                        Utils.StreamReader reader = new TracerReader(m_tracerProcess.getInputStream(),m_lPid);
                        reader.start();

                        DataOutputStream os = new DataOutputStream(m_tracerProcess.getOutputStream());
                        os.writeBytes(cmd + "\n"); // simulate enter key press
                        os.flush();
                    }

                }
            } catch (Exception e) {
                L.e("Failed to start tracing!");
                e.printStackTrace();
            }
        }

    }



}
