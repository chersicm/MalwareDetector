package alarilab.malwaredetector.database;

import android.content.ContentValues;
import android.content.Context;
import android.content.ContextWrapper;
import android.database.Cursor;
import android.database.DatabaseErrorHandler;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.provider.BaseColumns;
import android.util.Pair;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import alarilab.malwaredetector.core.AppData;
import alarilab.malwaredetector.database.tables.BaseTable;
import alarilab.malwaredetector.database.tables.BatteryUsageTable;
import alarilab.malwaredetector.database.tables.CpuUsageTable;
import alarilab.malwaredetector.database.tables.RamUsageTable;
import alarilab.malwaredetector.database.tables.RecordTable;
import alarilab.malwaredetector.database.tables.ScreenUsageTable;
import alarilab.malwaredetector.database.tables.SysCallsStatisticsTable;
import alarilab.malwaredetector.database.tables.SysCallsTable;
import alarilab.malwaredetector.shared.StatisticsData;
import alarilab.malwaredetector.utility.MergedDbDumper;
import alarilab.malwaredetector.utility.logger.L;


public class DbHelper extends SQLiteOpenHelper {

    public static final int DATABASE_VERSION = 1;
    public static final String DATABASE_NAME = "MonitorStatistics.db";
    public static final String DB_DUMP_FILE_NAME = "StatisticsData";
    private List<BaseTable> m_baseTables = new ArrayList<>();
    private SQLiteDatabase m_db = null;


    public DbHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
        init();
    }

    private void init() {
        m_baseTables.add(new ScreenUsageTable());
        m_baseTables.add(new BatteryUsageTable());
        m_baseTables.add(new CpuUsageTable());
        m_baseTables.add(new RamUsageTable());
        m_baseTables.add(new SysCallsStatisticsTable());
        m_baseTables.add(new SysCallsTable());
        m_baseTables.add(new RecordTable());

    }

    public SQLiteDatabase db() {
        return m_db;
    }

    public void onCreate(SQLiteDatabase db) {
        for (BaseTable table : m_baseTables) {
            db.execSQL(table.createQuery());
        }
    }

    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        L.w("Not yet supported!");
    }

    public void open() {
        m_db = getWritableDatabase(); // open in read and write mode

        checkConsistencyAndCorrect();
        deleteContentTables(); // Always clean tables each time the application is started!
    }

    private void checkConsistencyAndCorrect() {
        for (BaseTable table : m_baseTables) {
            if (!isTableExists(table.tableName())) {
                m_db.execSQL(table.createQuery());
            }
        }

    }

    public boolean isTableExists(String tableName) {
        Cursor cursor = m_db.rawQuery("select DISTINCT tbl_name from sqlite_master where tbl_name = '" + tableName + "'", null);
        if (cursor != null) {
            if (cursor.getCount() > 0) {
                cursor.close();
                return true;
            }
            cursor.close();
        }
        return false;
    }

    public boolean isReady() {
        return m_db != null && m_db.isOpen();
    }

    public void destroyDb() {

        for (BaseTable table : m_baseTables) {
            m_db.execSQL(table.deleteQuery());
        }

    }

    public int getNumRowsByCol(String tblName, String colName, String colVal) {
        int retVal;
        String countQuery = "SELECT  " + BaseColumns._ID + "  FROM " + tblName + " WHERE " + colName + " = ? ;";

        Cursor cursor = m_db.rawQuery(countQuery, new String[]{colVal});
        retVal = cursor.getCount();
        cursor.close();
        return retVal;
    }

    public void deleteRowsByCol(String tblName, String colName, String colVal, int numRows) {
        String ALTER_TBL = "DELETE FROM " + tblName +
                " WHERE " + BaseColumns._ID + " IN (SELECT " + BaseColumns._ID + " FROM " + tblName + " WHERE " + colName + " = ? ORDER BY _id LIMIT ?);";

        Cursor cursor = m_db.rawQuery(ALTER_TBL, new String[]{colVal, String.valueOf(numRows)});
        cursor.close();
    }

    public void deleteContentTables() {
        if (m_db != null) {
            m_db.delete(ScreenUsageTable.TABLE_NAME, null, null);
            m_db.delete(BatteryUsageTable.TABLE_NAME, null, null);
            m_db.delete(CpuUsageTable.TABLE_NAME, null, null);
            m_db.delete(RamUsageTable.TABLE_NAME, null, null);
            m_db.delete(SysCallsTable.TABLE_NAME, null, null);
            m_db.delete(SysCallsStatisticsTable.TABLE_NAME, null, null);
            m_db.delete(RecordTable.TABLE_NAME, null, null);
        }
        else {
            L.e("No database found! Maybe the init function was not called!");
        }
    }

    public boolean saveRecord(StatisticsData data) {
        boolean retVal = false;

        if (data.m_tableName != null && !data.m_tableName.isEmpty()) {
            m_db.beginTransaction();
            try {
                String tableName = RecordTable.TABLE_NAME;
                ContentValues content = getTable(tableName).values(data);
                m_db.insert(tableName, null, content);
                retVal = true;
                m_db.setTransactionSuccessful();
            } catch (Exception e) {
                L.e("An error occured while saving a record! [" + e.getMessage() + "]");
                e.printStackTrace();
            } finally {
                m_db.endTransaction();
            }
        } else {
            L.e("The stat data for pid [" + data.pid() + "] doesn't have a table name! Ignoring it!");
        }

        return retVal;
    }

    public boolean saveStatistics(List<StatisticsData> lStats) {

        HashMap<String, List<StatisticsData>> lStat_Order_By_TblName = new HashMap<>();
        boolean retVal = false;

        //organize the list by table name
        Iterator<StatisticsData> iter = lStats.iterator();
        while (iter.hasNext()) {
            StatisticsData stat = iter.next();
            if (stat.m_tableName != null && !stat.m_tableName.isEmpty()) {
                List<StatisticsData> lData = lStat_Order_By_TblName.get(stat.m_tableName);

                if (lData == null) {
                    List<StatisticsData> tmpArr = new ArrayList<>();
                    tmpArr.add(stat);
                    lStat_Order_By_TblName.put(stat.m_tableName, tmpArr);
                }
                else {
                    lData.add(stat);
                }

            }
            else {
                L.e("The stat data for pid [" + stat.pid() + "] doesn't have a table name! Ignoring it!");
            }
            iter.remove();
        }

        //For efficiency reasons, let's open a transaction to do all the job, since we're going to insert multiple rows and/or delete some of them
        //whenever needed.
        m_db.beginTransaction();

        try {

            Iterator<Map.Entry<String, List<StatisticsData>>> iter1 = lStat_Order_By_TblName.entrySet().iterator();
            while (iter1.hasNext()) {

                Map.Entry<String, List<StatisticsData>> entry = iter1.next();
                BaseTable table = getTable(entry.getKey());
                List<StatisticsData> lStatData = entry.getValue();

                int availableSize = checkTableLimitAndDelRows(entry.getKey(), lStatData.size()); // delete table rows if there is not enough space
                int numDataToRem = lStatData.size() - availableSize;

                // delete the data which cannot fit in the db
                Iterator<StatisticsData> iter2 = lStatData.iterator();
                while (numDataToRem > 0 && iter2.hasNext()) {
                    iter2.next();
                    iter2.remove();
                    --numDataToRem;
                }

                //insert data in db
                for (StatisticsData stat : lStatData) {
                    ContentValues content = table.values(stat);
                    m_db.insert(table.tableName(), null, content);
                }

                //release memory related to this stat data
                lStatData.clear();
                iter1.remove();

            }
            retVal = true;
            m_db.setTransactionSuccessful();
        } catch (Exception e) {
            L.e("An error occured while saving data! [" + e.getMessage() + "]");
            e.printStackTrace();
        } finally {
            m_db.endTransaction();
        }

        if (!lStats.isEmpty()) {
            L.e("Some statistis were not added into the database. " +
                    "Check if the table's name of stat is correct or if the table has been created!(see the class constructor)");
        }

        return retVal;
    }

    public BaseTable getTable(String tblName) {
        BaseTable ret = null;

        for (BaseTable table : m_baseTables) {
            if (table.tableName().equals(tblName)) {
                ret = table;
                break;
            }
        }

        return ret;
    }

    protected int checkTableLimitAndDelRows(String tblName, int numRowsToInsert) throws Exception {
        BaseTable table = getTable(tblName);
        int ret = numRowsToInsert;
        if (table != null) {
            int numTblRows = getNumRows(tblName);
            int maxTblRows = table.getMaxNumRows();

            if ((maxTblRows - numTblRows) < numRowsToInsert) {
                //compute the num rows to delete
                int numRowsToDel = numRowsToInsert + numTblRows - maxTblRows;
                deleteRows(tblName, numRowsToDel);
            }

            int numTblRows1 = getNumRows(tblName);
            if (numTblRows1 > maxTblRows) {
                L.e("An error occurs while deleting the table!");
            }

            if (numRowsToInsert > maxTblRows) {
                ret = maxTblRows;
                L.w("The data to save cannot fit in the table [" + tblName + "] " +
                        "due its maximun rows allowed [ NumRowsToInsert=" + numRowsToInsert + ", MAX_ROWS_ALLOWED= " + maxTblRows + "]");
                L.w("Therefore, some data won't be written in table. Only MAX_ROWS_ALLOWED data will be saved.");
            }
        }
        else {
            throw new Exception("Table [" + tblName + "] not found! Cannot proceed!");
        }

        return ret;
    }

    public int getNumRows(String tblName) {
        int retVal;
        String countQuery = "SELECT  " + BaseColumns._ID + "  FROM " + tblName + " ;";
        Cursor cursor = m_db.rawQuery(countQuery, null);
        retVal = cursor.getCount();
        cursor.close();
        return retVal;
    }

    public void deleteRows(String tblName, int numRows) {

        String countQuery = "SELECT  " + BaseColumns._ID + "  FROM " + tblName + " ORDER BY " + BaseColumns._ID + " LIMIT ? ;";
        Cursor cursor1 = m_db.rawQuery(countQuery, new String[]{String.valueOf(numRows)});
        L.d("Count: " + cursor1.getCount());
        cursor1.moveToFirst();
        while (!cursor1.isAfterLast()) {
            int id = cursor1.getInt(
                    cursor1.getColumnIndexOrThrow(BaseColumns._ID));
            L.d("id: " + id);
            m_db.delete(tblName, BaseColumns._ID + "=?", new String[]{String.valueOf(id)});
            cursor1.moveToNext();
        }

        cursor1.close();

        /*String ALTER_TBL = "DELETE FROM " + tblName +
                " WHERE " + BaseColumns._ID + " IN (SELECT " + BaseColumns._ID + " FROM " + tblName + " ORDER BY " + BaseColumns._ID + " LIMIT ? );";

        Cursor cursor = m_db.rawQuery(ALTER_TBL, new String[]{String.valueOf(numRows)});

        cursor.close();
        */
    }

    public int readTablesContentsAndSaveInFile(String filePath, boolean delAfterRead) {
        List<StatisticsData> lData = readContentsOfAllTables(delAfterRead);
        int ret = -1;
        List<Pair<String, List<StatisticsData>>> lStat_Group_By_TblName = new ArrayList<>();
        //HashMap<String, List<StatisticsData>> lStat_Group_By_TblName = new HashMap<>();

        //organize the list by table name
        Iterator<StatisticsData> iter = lData.iterator();
        while (iter.hasNext()) {
            StatisticsData stat = iter.next();
            if (stat.m_tableName != null && !stat.m_tableName.isEmpty()) {

                List<StatisticsData> lDataPerTbl = null;
                for(Pair<String, List<StatisticsData>> pdata: lStat_Group_By_TblName)
                {
                   if(pdata.first.equals(stat.m_tableName))
                   {
                       lDataPerTbl = pdata.second;
                       break;
                   }
                }

                if (lDataPerTbl == null) {
                    List<StatisticsData> tmpArr = new ArrayList<>();
                    tmpArr.add(stat);
                    lStat_Group_By_TblName.add(new Pair<>(stat.m_tableName, tmpArr));
                }
                else {
                    lDataPerTbl.add(stat);
                }

            }
            else {
                L.e("The stat data for pid [" + stat.pid() + "] doesn't have a table name! Ignoring it!");
            }
            iter.remove();
        }

        String path;

        if (filePath.equals(""))
            path = AppData.getInstance().getDatabasePath();
        else
            path = filePath;

        if (path.equals("")) {
            //Todo send a notification to user that we're creating the file in the private dir of the apps
            path = AppData.getInstance().appContext().getFilesDir().getPath();
        }

        File dir = new File(path);
        dir.mkdirs();

        if (dir.exists()) {
            Date date = new Date();
            SimpleDateFormat format = new SimpleDateFormat("dd-MM-hh-mm-ss");
            String dateStr = format.format(date);
            String name = DB_DUMP_FILE_NAME + "_"+dateStr +  "_" + String.valueOf(date.getTime()) + ".txt";
            File file = new File(dir, name);
            OutputStream outputStream;

            try {

                outputStream = new BufferedOutputStream(new FileOutputStream(file));
                try {

                    Iterator<Pair<String, List<StatisticsData>>> iter1 = lStat_Group_By_TblName.iterator();
                    String dataStr = BaseTable.HEADER_OUTPUT + "\n";
                    outputStream.write(dataStr.getBytes()); // write the column headers

                    while (iter1.hasNext()) {
                        Pair<String, List<StatisticsData>> entry = iter1.next();
                        BaseTable table = getTable(entry.first);
                        List<StatisticsData> stats = entry.second;
                        for (StatisticsData data : stats) {
                            dataStr = table.toFileFormat(data) + "\n";
                            outputStream.write(dataStr.getBytes());
                        }
                        iter1.remove();
                    }
                    ret = 0;
                } finally {
                    outputStream.close();
                }


            } catch (Exception e) {
                ret = -2;
                e.printStackTrace();
            }
        }
        else {
            L.e("Directory [" + dir.getAbsolutePath() + "] not created");
        }

        return ret;
    }

    public StatisticsData getFirstTableRows(String tblName)
    {
        StatisticsData ret = null;
        BaseTable table = getTable(tblName);
        if(table != null) {
            String queryStr = "SELECT *  FROM " + tblName + " ORDER BY " + BaseColumns._ID + " ASC LIMIT 1 ;";
            Cursor cursor1 = m_db.rawQuery(queryStr, null);
            cursor1.moveToFirst();
            if (!cursor1.isAfterLast()) {
                ret = table.toStatData(cursor1);
            }
            cursor1.close();
        }

        return ret;
    }

    public StatisticsData getLastTableRows(String tblName)
    {
        StatisticsData ret = null;
        BaseTable table = getTable(tblName);
        if(table != null) {
            String queryStr = "SELECT *  FROM " + tblName + " ORDER BY " + BaseColumns._ID + " DESC LIMIT 1 ;";
            Cursor cursor1 = m_db.rawQuery(queryStr, null);
            cursor1.moveToFirst();
            if (!cursor1.isAfterLast()) {
                ret = table.toStatData(cursor1);
            }
            cursor1.close();
        }
        else
        {
            L.e("Table [" + tblName + "] not found!");
        }

        return ret;
    }

    public long getMaxTimeStampStats()
    {
        long ret = 0;

        for (BaseTable table: m_baseTables)
        {
            StatisticsData stat = getLastTableRows(table.tableName());
            if(stat != null) {
               if(stat.m_timeStamp > ret)
                   ret = stat.m_timeStamp;
            }
        }

        return ret;
    }

    public long getMinTimeStampStats()
    {
        long ret = (new Date()).getTime();

        for (BaseTable table: m_baseTables)
        {
            StatisticsData stat = getFirstTableRows(table.tableName());
            if(stat != null) {
                if(stat.m_timeStamp < ret)
                    ret = stat.m_timeStamp;
            }
        }

        return ret;
    }

    public int readTablesMergeAndDumpToFile(String filePath, boolean delAfterRead){

        long minTime = getMinTimeStampStats();
        long maxTime = getMaxTimeStampStats();

        List<StatisticsData> lData = readContentsOfAllTables(delAfterRead);
        int ret = -1;
        List<Pair<String, List<StatisticsData>>> lStat_Group_By_TblName = new ArrayList<>();

        //organize the list by table name
        Iterator<StatisticsData> iter = lData.iterator();
        while (iter.hasNext()) {
            StatisticsData stat = iter.next();
            if (stat.m_tableName != null && !stat.m_tableName.isEmpty()) {

                List<StatisticsData> lDataPerTbl = null;
                for(Pair<String, List<StatisticsData>> pdata: lStat_Group_By_TblName)
                {
                    if(pdata.first.equals(stat.m_tableName))
                    {
                        lDataPerTbl = pdata.second;
                        break;
                    }
                }

                if (lDataPerTbl == null) {
                    List<StatisticsData> tmpArr = new ArrayList<>();
                    tmpArr.add(stat);
                    lStat_Group_By_TblName.add(new Pair<>(stat.m_tableName, tmpArr));
                }
                else {
                    lDataPerTbl.add(stat);
                }

            }
            else {
                L.e("The stat data for pid [" + stat.pid() + "] doesn't have a table name! Ignoring it!");
            }
            iter.remove();
        }

        String path;

        if (filePath.equals(""))
            path = AppData.getInstance().getDatabasePath();
        else
            path = filePath;

        if (path.equals("")) {
            //Todo send a notification to user that we're creating the file in the private dir of the apps
            path = AppData.getInstance().appContext().getFilesDir().getPath();
        }

        File dir = new File(path);
        dir.mkdirs();

        if (dir.exists()) {
            Date date = new Date();
            SimpleDateFormat format = new SimpleDateFormat("dd-MM-hh-mm-ss");
            String dateStr = format.format(date);
            String name = DB_DUMP_FILE_NAME + "_"+dateStr +  "_" + String.valueOf(date.getTime()) + ".txt";
            File file = new File(dir, name);
            OutputStream outputStream;

            try {

                outputStream = new BufferedOutputStream(new FileOutputStream(file));
                try {

                    Iterator<Pair<String, List<StatisticsData>>> iter1 = lStat_Group_By_TblName.iterator();
                    String dataStr = BaseTable.HEADER_OUTPUT2 + "\n";
                    outputStream.write(dataStr.getBytes()); // write the column headers

                    MergedDbDumper dbDumper = new MergedDbDumper(minTime,maxTime);

                    while (iter1.hasNext()) {
                        Pair<String, List<StatisticsData>> entry = iter1.next();

                        List<StatisticsData> stats = entry.second;
                        for (StatisticsData data : stats) {
                            dbDumper.add(data);
                        }
                        iter1.remove();
                    }
                    dbDumper.makeStatsAverage();
                    dbDumper.fillEmptyStats();
                    dbDumper.saveToFile(outputStream);

                    ret = 0;
                } finally {
                    outputStream.close();
                }


            } catch (Exception e) {
                ret = -2;
                e.printStackTrace();
            }
        }
        else {
            L.e("Directory [" + dir.getAbsolutePath() + "] not created");
        }

        return ret;
    }

    public List<StatisticsData> readContentsOfAllTables(boolean delRowsAfterRead) {
        List<StatisticsData> ret = new ArrayList<>();

        for (BaseTable table : m_baseTables) {
            List<StatisticsData> lStats = readTableContents(table.tableName(), delRowsAfterRead);
            if (lStats != null && !lStats.isEmpty()) {
                ret.addAll(lStats);
            }
        }

        return ret;
    }

    public List<StatisticsData> readTableContents(String tblName, boolean delRowsAfterRead) {
        List<StatisticsData> lStats = new ArrayList<>();

        BaseTable table = getTable(tblName);

        String[] projection = table.projection();

        String sortOrder = table.defaultSortOrder();

        Cursor cursor = m_db.query(
                tblName,
                projection,
                null,
                null,
                null,
                null,
                sortOrder
        );

        lStats.addAll(table.cursorDataToStats(cursor));
        cursor.close();

        if (delRowsAfterRead) {
            m_db.delete(tblName, null, null);
        }

        return lStats;
    }

    public static class DbContext extends ContextWrapper {

        public DbContext(Context base) {
            super(base);
        }

        @Override
        public File getDatabasePath(String name) {
            String dbfile = AppData.getInstance().getDatabasePath() + File.separator + name;

            if (!dbfile.endsWith(".db")) {
                dbfile += ".db";
            }

            File result = new File(dbfile);

            if (!result.getParentFile().exists()) {
                result.getParentFile().mkdirs();
            }

            return result;
        }

        /* this version is called for android devices >= api-11 */
        @Override
        public SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler) {
            return openOrCreateDatabase(name, mode, factory);
        }

        /* this version is called for android devices < api-11 */
        @Override
        public SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory) {
            return SQLiteDatabase.openOrCreateDatabase(getDatabasePath(name), null);
        }
    }
}