package alarilab.malwaredetector.core;

import android.content.Context;
import android.os.Handler;
import android.os.Message;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import alarilab.malwaredetector.core.resources.AppProcess;
import alarilab.malwaredetector.core.resources.Battery;
import alarilab.malwaredetector.core.resources.DeviceProcesses;
import alarilab.malwaredetector.core.resources.Display;
import alarilab.malwaredetector.core.resources.Memory;
import alarilab.malwaredetector.core.resources.Processor;
import alarilab.malwaredetector.core.resources.ResourceInfos;
import alarilab.malwaredetector.core.resources.ResourceUsage;
import alarilab.malwaredetector.services.DbHandler;
import alarilab.malwaredetector.services.MalwareAnalyser;
import alarilab.malwaredetector.shared.DataExchanged;
import alarilab.malwaredetector.shared.Signal;
import alarilab.malwaredetector.shared.StatisticsData;
import alarilab.malwaredetector.utility.Utils;
import alarilab.malwaredetector.utility.logger.L;


public class DeviceInfos {

    protected boolean m_quitting = false;
    private Handler m_messageHandler = null;
    private List<ResourceInfos> m_listResInfos = new ArrayList<ResourceInfos>();
    private Context m_appContext = null;
    private Timer m_uiRefreshTimer = null;
    private long m_uiRefreshPeriod = 0;

    public DeviceInfos(Context context, Handler handler) {
        m_messageHandler = handler;
        m_appContext = context;
    }

    public void setExiting(boolean val) {
        this.m_quitting = val;
    }

    public synchronized boolean isQuitting() {
        return this.m_quitting;
    }

    public Handler getMessageHandler() {
        return m_messageHandler;
    }

    public void init() {
        m_quitting = false;
        addNewResource(new DeviceProcesses(this, AppData.getInstance().processListRefreshTime())); // load first the list of processes
        addNewResource(new Memory(this, AppData.getInstance().memRefreshTime()));
        addNewResource(new Processor(this, AppData.getInstance().cpuRefreshTime()));
        addNewResource(new Battery(this, AppData.getInstance().batteryRefreshTime()));
        addNewResource(new Display(this, 0));
        updateUIRefreshTimer(AppData.getInstance().uiRefreshTime());
    }

    private void addNewResource(ResourceInfos res) {
        res.init();
        m_listResInfos.add(res);
    }

    private void updateUIRefreshTimer(long time) {
        if (m_uiRefreshPeriod != time) {

            stopUIRefreshTimer();
            if (time > 0) {
                m_uiRefreshPeriod = time;
                if (m_uiRefreshTimer == null)
                    m_uiRefreshTimer = new Timer("UI_refreshTimerThread", false);
                L.d("UI_refreshTimerThread Started!");
                m_uiRefreshTimer.schedule(new TimerTask() {
                                              @Override
                                              public void run() {
                                                  ((DeviceProcesses) getResource(ResourceUsage.RESOURCETYPE.PROC)).notifyUi();
                                              }
                                          },
                        1000,
                        m_uiRefreshPeriod);
            } else if (time == 0) {
                m_uiRefreshPeriod = 0;
                L.d("UI_refreshTimerThread Stopped!");
            }
        }
    }

    private void stopUIRefreshTimer() {
        if (m_uiRefreshTimer != null) {
            m_uiRefreshTimer.cancel();
            m_uiRefreshTimer.purge();
            m_uiRefreshTimer = null;
        }
    }

    public synchronized ResourceInfos getResource(ResourceUsage.RESOURCETYPE type) {
        ResourceInfos ret = null;
        if (m_listResInfos != null) {
            for (ResourceInfos res : m_listResInfos) {
                if (res.type() == type) {
                    ret = res;
                    break;
                }
            }
        }
        return ret;
    }

    public void clear() {
        stopUIRefreshTimer();

        if (m_listResInfos != null) {
            Iterator<ResourceInfos> iter = m_listResInfos.iterator();
            while (iter.hasNext()) {
                ResourceInfos res = iter.next();
                res.clear();
                iter.remove();
            }
            m_listResInfos.clear();
        }
        m_appContext = null;
        m_messageHandler = null;

        m_listResInfos = null;
    }

    public List<StatisticsData> getResourceUsageInfos(ResourceUsage.RESOURCETYPE type) {
        List<StatisticsData> ret = null;
        DeviceProcesses procs = (DeviceProcesses) getResource(ResourceUsage.RESOURCETYPE.PROC);
        if (procs != null) {
            ret = procs.getResourceUsageInfos(type);
        }
        return ret;
    }

    public DataExchanged.ResourceData getResourceData(ResourceUsage.RESOURCETYPE type) {
        ResourceInfos res = getResource(type);
        DataExchanged.ResourceData ret = null;
        if (res != null) {
            ret = res.getInfos();
            if (ret == null)
                L.w("The resource infos for resource type (" + type + ") was not defined!");
        } else {
            L.e("The requested resource with type (" + type + ") does not exist!");
        }

        return ret;
    }

    public void removeHandledMessages() {
        m_messageHandler.removeMessages(Signal.MONITOR_CONFIG_CHANGED);
        m_messageHandler.removeMessages(Signal.REFRESH_TIME_CHANGED);
        m_messageHandler.removeMessages(Signal.PROCESS_MONITOR_FLAG_CHANGED);
        m_messageHandler.removeMessages(Signal.MONITOR_ALL_PROCESSES_FLAG_CHANGED);
        m_messageHandler.removeMessages(Signal.SYNC_CPUINFOS_TIMEOUT);
        m_messageHandler.removeMessages(Signal.SYNC_PID_TIMEOUT);
        m_messageHandler.removeMessages(Signal.SYNC_BATTERY_TIMEOUT);
        m_messageHandler.removeMessages(Signal.SYNC_MEMINFOS_TIMEOUT);
        m_messageHandler.removeMessages(Signal.UPDATE_SYSCALL_MONITOR_PROC_LIST);
    }

    private int msg_count = 0;
    private final Object m_msgCountMutex = new Object();

    public boolean handleMessage(Message msg) {
        //To avoid memory leaks, Remember to remove any pending handled messages in the function removeHandledMessages().
        //This function is called when the service is stopped.

        boolean handled = false;

        switch (msg.what) {
            case Signal.SYNC_CPUINFOS_TIMEOUT:
            case Signal.SYNC_PID_TIMEOUT:
            case Signal.SYNC_BATTERY_TIMEOUT:
            case Signal.SYNC_MEMINFOS_TIMEOUT: {
                synchronized (m_msgCountMutex) {
                    msg_count++;
                    onTimeOutEvent(msg);
                }
                handled = true;
                break;
            }

            case Signal.REFRESH_TIME_CHANGED: {
                onRefreshTimeChanged(msg);
                handled = true;
                break;
            }

            case Signal.MONITOR_CONFIG_CHANGED: {
                onMonitorConfigChanged(msg);
                handled = true;
                break;
            }
            case Signal.MONITOR_SYSTEM_APPS_FLAG_CHANGED: {
                DeviceProcesses res = (DeviceProcesses) getResource(ResourceUsage.RESOURCETYPE.PROC);
                if (res != null)
                    res.refresh();

                break;
            }
            case Signal.MONITOR_ALL_PROCESSES_FLAG_CHANGED: {
                DeviceProcesses res = (DeviceProcesses) getResource(ResourceUsage.RESOURCETYPE.PROC);
                if (res != null)
                    res.updateProcMonitorFlag();

                break;
            }
            case Signal.PROCESS_MONITOR_FLAG_CHANGED: {
                DeviceProcesses res = (DeviceProcesses) getResource(ResourceUsage.RESOURCETYPE.PROC);
                if (res != null) {
                    Signal.In2<Integer, Integer> in = (Signal.In2<Integer, Integer>) msg.obj;
                    res.updateProcMonitorFlag(in.input1, Utils.toBoolean(in.input2));
                }

                break;
            }

            case Signal.UPDATE_SYSCALL_MONITOR_PROC_LIST: {
                DeviceProcesses res = (DeviceProcesses) getResource(ResourceUsage.RESOURCETYPE.PROC);
                if (res != null) {
                    res.notifySystCallMonitor();
                }
                break;
            }
            default: {
                L.w("Message with id: " + msg.what + " not handled!");
            }
        }

        return handled;
    }

    private void onTimeOutEvent(Message msg) {
        DeviceProcesses procList = (DeviceProcesses) getResource(ResourceUsage.RESOURCETYPE.PROC);
        if (procList != null) {
            try {
                procList.refreshResourceUsage(ResourceUsage.RESOURCETYPE.values()[msg.arg1]);
                // remove pending messages with same id. we've just finished to refresh! let's wait another timeout event
                m_messageHandler.removeMessages(msg.what);
                // notify MalwareAnalyser
                if (msg_count == 4) {
                    msg_count = 0;
                    notifyMalwareAnalyser();
                }
            } catch (Exception e) {
                L.e("The following error occurs while refreshing the resource infos with timeout type ("
                        + msg.what + "):\n" + e.toString());
                e.printStackTrace();
            }
        } else {
            L.e("Failed to handle a timeout event! There is no DeviceProcesses");
        }
    }

    // notify the MalwareAnalyser service that the resource usage stats have been updated
    private void notifyMalwareAnalyser() {
        if (!MalwareAnalyser.isNull()) {
            MalwareAnalyser analyser = MalwareAnalyser.getInstance();
            List<AppProcess> procs = ((DeviceProcesses) getResource(ResourceUsage.RESOURCETYPE.PROC)).getProcesses();
            Signal sig = new Signal(analyser.handler());
            sig.m_signalId = Signal.MALWARE_ANALYSER_TIMEOUT;
            sig.m_obj = new ArrayList<>(procs);
            sig.emit();
        } else {
            L.e("MalwareAnalyser not initialized: DevicesInfos could not notify update", "DeviceInfos");
        }
    }

    private void onRefreshTimeChanged(Message msg) {
        AppData.RefreshInfos infos = (AppData.RefreshInfos) msg.obj;

        if (infos != null) {
            if (infos.m_resourceType == ResourceUsage.RESOURCETYPE.DISPLAY) {
                updateUIRefreshTimer(infos.m_refreshTime);
            } else {
                ResourceInfos res = getResource(infos.m_resourceType);
                res.updateRefreshTime(infos.m_refreshTime);
            }

        }
    }

    private void onMonitorConfigChanged(Message msg) {
        if (m_listResInfos != null) {
            for (ResourceInfos res : m_listResInfos) {
                res.onConfigChanged();
            }
        }
    }

    public void refreshResourceUsage(ResourceUsage.RESOURCETYPE type) {
        DeviceProcesses proc = (DeviceProcesses) getResource(ResourceUsage.RESOURCETYPE.PROC);
        if (proc != null)
            proc.refreshResourceUsage(type);
    }


    public void gatherResourceUsage(ResourceUsage.RESOURCETYPE type) {

        ResourceInfos res = getResource(type);

        if (res != null) {
            List<StatisticsData> lStats = res.getUsageInfos();

            if (lStats != null) {
                //save them in a database

                if (AppData.getInstance().dbHandlerEnabled() && lStats.size() > 0)
                    DbHandler.getInstance().saveData(lStats, true);

            } else {
                L.e("The resource [" + type + "] returns null statistics list!");
            }

        } else {
            L.e("No resource [" + type + "] found!");
        }

    }

}
