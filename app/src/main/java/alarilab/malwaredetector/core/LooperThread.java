package alarilab.malwaredetector.core;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;

import alarilab.malwaredetector.utility.Utils;
import alarilab.malwaredetector.utility.logger.L;

/**
 * Created by vidal on 01.03.15.
 */
public class LooperThread extends Thread implements Handler.Callback {
    public static final int MAXTIME_FOR_WAITING_THREAD_EXITED = 200;
    public static final int MAXTIME_FOR_WAITING_THREAD_STARTED = 200;
    public static final int MAXATTEMPT_FOR_WAITING_THREAD_STARTED = 5;
    public static final int MAXATTEMPT_FOR_WAITING_THREAD_EXITED = 50;
    protected Handler m_Handler = null;
    protected StopTask m_stopTask = new StopTask();
    protected Looper m_looper = null;
    protected String m_serviceName = "";
    private Object m_startedLock = new Object();
    private int m_serviceId = -1;

    public LooperThread(int srvId, String name) {
        super(name + "_Service");
        m_serviceId = srvId;
        setPriority(Thread.NORM_PRIORITY);
        m_serviceName = name;
    }

    protected void onStart() {}

    protected void onQuit() {}

    public final void run() {
        synchronized (m_startedLock) {
            Looper.prepare();
            m_Handler = new Handler(this);
            m_looper = Looper.myLooper();
            m_startedLock.notifyAll();
        }
        AppData.registerService(m_serviceId, m_Handler);
        Looper.loop();

        L.d("Exiting from service [" + m_serviceName + "]...", "EXIT");
    }

    public Handler handler() {
        return m_Handler;
    }


    /*

    This function is called when the service is stopped. It should be overridden by subclasses in order to remove any
    pending messages that would be handled if the services was running.

    */
    protected void removeHandledMessages() {
    }

    @Override
    public boolean handleMessage(Message msg) {
        L.w("This function does nothing!");
        return true;
    }

    public synchronized void startService() throws StartingException {

        if (!isAlive()) {
            start(); // start the thread
            try {
                synchronized (m_startedLock) {
                    int attempt = MAXATTEMPT_FOR_WAITING_THREAD_STARTED;
                    while (attempt > 0) {
                        m_startedLock.wait(MAXTIME_FOR_WAITING_THREAD_STARTED);
                        --attempt;
                    }
                }

                if (!isAlive() || m_Handler == null) {
                    throw new StartingException("The " + m_serviceName + " could not be started!");
                } else {
                    L.d("Sending init command!");
                    m_Handler.post(new InitTask());
                }

            } catch (InterruptedException e) {
                L.e("failed!");
                e.printStackTrace();
            }
        } else {
            L.w("The service [" + m_serviceName + "] is already running!");
        }
    }

    public synchronized boolean stopService() {
        L.d(">> service [" + m_serviceName + "]");
        boolean retVal = false;

        if (isAlive()) {
            AppData.deregisterService(m_serviceId);

            if (m_stopTask != null) {
                m_Handler.postAtFrontOfQueue(m_stopTask);
            } else {
                L.w("The default StopTak was unset! The service [ " + m_serviceName + "] may not properly quit!");
                if (m_looper != null) {
                    m_looper.quit();
                } else {
                    L.e("No looper thread was set!");
                }
            }

            try {

                int attempt = MAXATTEMPT_FOR_WAITING_THREAD_EXITED;
                while (isAlive() && attempt > 0) {
                    wait(MAXTIME_FOR_WAITING_THREAD_EXITED);
                    --attempt;
                }

            } catch (InterruptedException e) {
                L.e("");
                e.printStackTrace();
            }

        }


        retVal = !isAlive();

        if (!retVal) {
            L.w("Could not stop correctly the service [" + m_serviceName + "]");
        }
        L.d("<<");
        return retVal;
    }


    public synchronized boolean isRunning() {
        return isAlive();
    }

    public class StartingException extends Exception {
        public StartingException(String msg) {
            super(msg);
        }

    }

    private class InitTask implements Runnable {
        @Override
        public void run() {
            onStart();
        }
    }

    private class StopTask implements Runnable {
        @Override
        public void run() {

            onQuit();

            removeHandledMessages();

            m_Handler.removeCallbacks(new InitTask());
            m_Handler = null;
            Looper looper = Looper.myLooper();

            if (Utils.getAndroidApiLevel() >= 18)
                looper.quitSafely();
            else
                looper.quit();
        }
    }
}
