package alarilab.malwaredetector.core.resources;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Date;
import java.util.List;

import alarilab.malwaredetector.core.AppData;
import alarilab.malwaredetector.core.DeviceInfos;
import alarilab.malwaredetector.database.tables.CpuUsageTable;
import alarilab.malwaredetector.shared.DataExchanged;
import alarilab.malwaredetector.shared.Signal;
import alarilab.malwaredetector.shared.StatisticsData;
import alarilab.malwaredetector.utility.Utils;
import alarilab.malwaredetector.utility.logger.L;

/**
 * Created by vidal on 27.03.15.
 */
public class Processor extends ResourceInfos {

    private DeviceInfos deviceInfos;

    public Processor(DeviceInfos deviceInfos, long delay) {
        super(ResourceUsage.RESOURCETYPE.CPU, delay);
        this.deviceInfos = deviceInfos;
        setMonitored(AppData.getInstance().cpuMonitorEnabled());
        this.m_handler = deviceInfos.getMessageHandler();
        this.m_timeOutMsgId = Signal.SYNC_CPUINFOS_TIMEOUT;
        m_resData = new DataExchanged.CpuData();
    }

    @Override
    public void onConfigChanged() {
        setMonitored(AppData.getInstance().cpuMonitorEnabled());
    }

    @Override
    public List<StatisticsData> getUsageInfos() {
        return deviceInfos.getResourceUsageInfos(m_resourceType);
    }

    @Override
    public void init() {
        super.init();
        readInfos();
    }

    void readInfos() {
        DataExchanged.CpuData data = (DataExchanged.CpuData) m_resData;
        if (m_resData != null) {
            data.m_numCpus = Runtime.getRuntime().availableProcessors();
            data.m_cpuName = System.getProperty("os.arch");
            data.m_cpuMaxFreq = Utils.getCpuMaxFreq();
        }
    }

    @Override
    public void refresh() {
        //update cpu usage of processes
        deviceInfos.refreshResourceUsage(m_resourceType);
    }


    public static class Usage extends ResourceUsage {

        protected float m_percentage = 0;
        protected long m_procWorkCpuTime = 0;
        protected long m_totalCpuWorkTime = 0;
        protected long m_idleCpuTime = 0;
        protected float m_cpuRatio = 0;

        public Usage(int uid, int pid, String pckName) {
            super(RESOURCETYPE.CPU, uid, pid, pckName);
           /* init();*/
        }

        public float getPercentage() {
            return m_percentage;
        }

        @Override
        public void refresh() {
            String processPid = Integer.toString(m_pid);
            String cpuStatPath = "/proc/" + processPid + "/stat";

            long newProcCpuWorkTime = 0;
            long newTotalCpuWorkTime = 0;
            long newIdleCpuTime = 0;

            //get infos about the cpu usage by the process with m_pid
            try {

                RandomAccessFile processCpuInfo = new RandomAccessFile(cpuStatPath, "r");
                String line = "";
                StringBuffer stringBuffer = new StringBuffer();
                stringBuffer.setLength(0);

                while ((line = processCpuInfo.readLine()) != null) {
                    stringBuffer.append(line + "\n");
                }
                String[] tok = stringBuffer.toString().split(" ");

                if (tok.length > 14) {
                    // for more infos see http://man7.org/linux/man-pages/man5/proc.5.html
                    newProcCpuWorkTime = Long.parseLong(tok[13]) //(utime)Amount of time that this process has been scheduled in user mode, measured in clock ticks (1/100 sec)
                            + Long.parseLong(tok[14]); //(stime)Amount of time that this process has been scheduled in kernel mode, measured in clock ticks
                }

                processCpuInfo.close();

            } catch (FileNotFoundException e) {
                L.w("The process was killed!");
                e.printStackTrace();
            } catch (IOException e) {

                e.printStackTrace();
            }

            // get infos about overall cpu usage
            try {
                // monitor total and idle cpu stat of certain process
                RandomAccessFile cpuInfo = new RandomAccessFile("/proc/stat", "r");
                String[] toks = cpuInfo.readLine().split("\\s");

               /* for(int i=0; i<toks.length ; ++i)
                {
                    L.d("toks [" + i + "]->" + toks[i]);
                }*/

                if (toks.length >= 5) {
                    newIdleCpuTime = Long.parseLong(toks[5]);
                    newTotalCpuWorkTime = Long.parseLong(toks[2]) //Time spent in user mode.
                            + Long.parseLong(toks[3]) //Time spent in user mode with low priority (nice)
                            + Long.parseLong(toks[4]) //Time spent in system mode.
                            + Long.parseLong(toks[5]) //Time spent in the idle task.
                            + Long.parseLong(toks[6]) //Time waiting for I/O to complete. (since Linux 2.5.41)
                    // + Long.parseLong(toks[6]) //Time servicing interrupts. (since Linux 2.6.0-test4)
                    // + Long.parseLong(toks[7]) // Time servicing softirqs. (since Linux 2.6.0-test4)
                    //+ Long.parseLong(toks[8])  //Stolen time, which is the time spent in
                    // other operating systems when running in a virtualized environment (since Linux 2.6.11)
                    //+ Long.parseLong(toks[9])  //guest- Time spent running a virtual CPU for guest OS (since Linux 2.6.24)
                    //+ Long.parseLong(toks[10])  //guest_nice - Time spent running a niced guest OS (since Linux 2.6.33)
                    ;
                }

                cpuInfo.close();

            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }

            //let's compute how much this process consumed the cpu resource from the last refresh.
            if (newTotalCpuWorkTime != 0 && newTotalCpuWorkTime != m_totalCpuWorkTime) {
                m_percentage = 100 * ((float) (newProcCpuWorkTime - m_procWorkCpuTime) / (float) (newTotalCpuWorkTime - m_totalCpuWorkTime));
                m_cpuRatio = 100 * ((float) ((newTotalCpuWorkTime - newIdleCpuTime) - (m_totalCpuWorkTime - m_idleCpuTime)) / (float) (newTotalCpuWorkTime - m_totalCpuWorkTime));
                m_procWorkCpuTime = newProcCpuWorkTime;
                m_totalCpuWorkTime = newTotalCpuWorkTime;
                m_idleCpuTime = newIdleCpuTime;
            }
            else {
                L.w("Something wrong happens while refreshing the cpu usage of proc with pid [" + m_pid + "]");
                m_procWorkCpuTime = 0;
                m_totalCpuWorkTime = 0;
                m_idleCpuTime = 0;
            }
        }

        @Override
        public StatisticsData getUsageInfos() {
            StatisticsData data = new StatisticsData(m_pid);
            data.m_tableName = CpuUsageTable.TABLE_NAME;
            data.m_percentage = m_percentage;
            data.m_timeStamp = (new Date()).getTime();
            return data;
        }
    }
}
