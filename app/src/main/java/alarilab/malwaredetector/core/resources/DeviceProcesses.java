package alarilab.malwaredetector.core.resources;

import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.text.TextUtils;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import alarilab.malwaredetector.core.AppData;
import alarilab.malwaredetector.core.DeviceInfos;
import alarilab.malwaredetector.services.SysCallsMonitor;
import alarilab.malwaredetector.shared.Signal;
import alarilab.malwaredetector.shared.StatisticsData;
import alarilab.malwaredetector.utility.logger.L;

/**
 * Created by vidal on 27.03.15.
 */
public class DeviceProcesses extends ResourceInfos {

    private final Object m_listProcMutex = new Object();
    private DeviceInfos deviceInfos;
    private List<AppProcess> m_listAppProcesses = new ArrayList<AppProcess>();
    private static boolean isFirstTime = true;

    public DeviceProcesses(DeviceInfos deviceInfos, long delay) {
        super(ResourceUsage.RESOURCETYPE.PROC, delay);
        this.deviceInfos = deviceInfos;
        setMonitored(AppData.getInstance().processMonitorEnabled());
        this.m_handler = deviceInfos.getMessageHandler();
        this.m_timeOutMsgId = Signal.SYNC_PID_TIMEOUT;
    }

    @Override
    public void onConfigChanged() {
        setMonitored(AppData.getInstance().processMonitorEnabled());
    }

    @Override
    public List<StatisticsData> getUsageInfos() {
        return null;
    }

    public List<AppProcess> getProcesses() {
        synchronized (m_listProcMutex) {
            return m_listAppProcesses;
        }
    }

    @Override
    public void notifyUi() {
        synchronized (m_listProcMutex) {
            if (m_listAppProcesses != null) {
                Signal sig =  AppData.obtainSignal(AppData.MAINACTIVITYSERVICE);//new Utils.Signal();
                if(sig != null) {
                    sig.m_signalId = Signal.PROCESS_LIST_UPDATED;
                    sig.m_obj = new ArrayList<>(m_listAppProcesses);
                    sig.emit();
                }
            }
        }
    }

    @Override
    public void refresh() {

        boolean isChanged = false;
        List<AppProcess> listProc = retrieveProcessList();

        Iterator<AppProcess> currIter = m_listAppProcesses.iterator();
        boolean found;
        while (currIter.hasNext() && !deviceInfos.isQuitting()) {
            AppProcess proc = currIter.next();
            found = false;

            Iterator<AppProcess> newIter = listProc.iterator();
            while (newIter.hasNext() && !deviceInfos.isQuitting()) {
                AppProcess proc1 = newIter.next();
                if (proc1.isEqual(proc)) {
                    found = true;
                    newIter.remove();
                    break;
                }
            }

            if (!found) {
                synchronized (m_listProcMutex) {
                    isChanged = true;
                    L.d("The process [" + proc.processName() + "] is gone! Removing it from list!");
                    proc.clear();
                    currIter.remove();
                }
            }

        }

        if (!deviceInfos.isQuitting()) {
            //are there new processes?
            if (!listProc.isEmpty()) {

                isChanged = true;
                addNewProcesses(listProc);
            }

            if (isChanged) {

                boolean uirefreshTime = AppData.getInstance().uiRefreshTime() != 0;

                if(uirefreshTime || (!uirefreshTime&&isFirstTime))
                    notifyUi();

                notifySystCallMonitor();

            }
            isFirstTime = false;
        }

    }

    @Override
    public void clear() {
        super.clear();

        synchronized (m_listProcMutex) {
            Iterator<AppProcess> iter = m_listAppProcesses.iterator();
            while (iter.hasNext()) {
                AppProcess proc = iter.next();
                proc.clear();
                iter.remove();
            }
            m_listAppProcesses.clear();

            m_listAppProcesses = null;
        }
    }

    public void updateProcMonitorFlag() {
        for (AppProcess proc : m_listAppProcesses) {
            proc.setMonitored(AppData.getInstance().monitorAllProcessesEnabled());
        }
        notifyChanges();
    }

    private void notifyChanges() {
        notifyUi();
        notifySystCallMonitor();
    }

    public void notifySystCallMonitor() {

        //we notify only the monitored processes
        List<AppProcess> l_monitoredProc = new ArrayList<AppProcess>();
        for (AppProcess proc : m_listAppProcesses) {
            if (proc.isMonitored())
                l_monitoredProc.add(proc);
        }

        if (AppData.getInstance().sysCallMonitorEnabled())
            SysCallsMonitor.getInstance().updateProcList(l_monitoredProc);
    }

    public void updateProcMonitorFlag(int pid, boolean enabled) {
        for (AppProcess proc : m_listAppProcesses) {
            if (pid == proc.pid()) {
                proc.setMonitored(enabled);
                break;
            }
        }
        notifyChanges();
    }

    public void refreshResourceUsage(ResourceUsage.RESOURCETYPE type) {

        if (type == m_resourceType) {
            refresh();
        } else {

            for (AppProcess proc : m_listAppProcesses) {
                proc.refresh(type);
            }

            //now save the gathered infos about the resource usage of all processes.For now,
            // let's save them in a database
            deviceInfos.gatherResourceUsage(type);
        }

    }

    private List<AppProcess> retrieveProcessList() {

        List<AppProcess> retVal;
        Context context = AppData.getInstance().appContext();
        PackageManager packMng = context.getPackageManager();
        ActivityManager actMng = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);

        retVal = new ArrayList<AppProcess>();

        List<ApplicationInfo> appList = packMng.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);
        List<ActivityManager.RunningAppProcessInfo> runningProcessList = actMng.getRunningAppProcesses();

        AppProcess processInfo;

        for (ApplicationInfo appInfo : appList) {

            if (!AppData.getInstance().systemAppsMonitoringEnabled()
                    && (appInfo.flags & ApplicationInfo.FLAG_SYSTEM) > 0) {
                //L.d("Skipping the system application [" + appInfo.processName + "]");
                continue;
            }
            processInfo = null;

            for (ActivityManager.RunningAppProcessInfo runningAppProcessInfo : runningProcessList) {

                if (TextUtils.equals(runningAppProcessInfo.processName, appInfo.processName)
                        ) {
                    int pid = runningAppProcessInfo.pid;

                    if (!isAlreadyLoaded(pid, retVal)) {
                        processInfo = new AppProcess(runningAppProcessInfo.uid,
                                runningAppProcessInfo.pid,
                                appInfo.loadLabel(packMng).toString(),
                                appInfo.processName,
                                appInfo.loadIcon(packMng)
                        );
                    }
                    else {
                        L.w("Found a duplicated process with pid [" + pid + "]! ignoring it...");
                    }

                    break;
                }

            }

            if (deviceInfos.isQuitting())
                break;

            if (processInfo != null) {
                retVal.add(processInfo);
            }

        }

        return retVal;
    }

    void addNewProcesses(List<AppProcess> lProc) {
        synchronized (m_listProcMutex) {
            for (AppProcess appInfo : lProc) {
                try {
                    appInfo.init();
                    appInfo.setMonitored(AppData.getInstance().monitorAllProcessesEnabled());
                    m_listAppProcesses.add(appInfo);
                } catch (Exception e) {
                    L.e("The initialization of process [" + appInfo.processName() + "] failed with the following error: ");
                    e.printStackTrace();
                }
            }
        }
    }

    private boolean isAlreadyLoaded(int pid, List<AppProcess> procList) {

        boolean retval = false;
        for (AppProcess proc : procList) {
            if (proc.pid() == pid) {
                retval = true;
                break;
            }
        }
        return retval;
    }

    public List<StatisticsData> getResourceUsageInfos(ResourceUsage.RESOURCETYPE type) {
        List<StatisticsData> lStats = new ArrayList<StatisticsData>();

        if (type != m_resourceType) {
            for (AppProcess proc : m_listAppProcesses) {
                if (proc.isMonitored()) {
                    StatisticsData stat = proc.getUsageInfos(type);
                    if (stat != null)
                        lStats.add(stat);
                    else
                        L.w("Returned a null statistics for resource [" + type + "]");
                }
            }
        }

        return lStats;
    }

}