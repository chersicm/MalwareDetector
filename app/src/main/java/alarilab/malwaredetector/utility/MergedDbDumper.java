package alarilab.malwaredetector.utility;

import android.util.Pair;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import alarilab.malwaredetector.core.AppData;
import alarilab.malwaredetector.database.tables.BaseTable;
import alarilab.malwaredetector.database.tables.BatteryUsageTable;
import alarilab.malwaredetector.database.tables.CpuUsageTable;
import alarilab.malwaredetector.database.tables.RamUsageTable;
import alarilab.malwaredetector.database.tables.ScreenUsageTable;
import alarilab.malwaredetector.database.tables.SysCallsStatisticsTable;
import alarilab.malwaredetector.shared.StatisticsData;
import alarilab.malwaredetector.utility.logger.L;

public class MergedDbDumper {
    private HashMap<Integer,ArrayList<MergedStats> > m_mergedStatsByPid = new HashMap<>();
    private long m_minTimeStamp;
    private long m_maxTimeStamp;
    private long m_resTime = AppData.getInstance().dbDumpResTime(); //milliseconds
    private List<Long> m_refTime = null;

    public static  long normalizeTime(long time, long resTime)
    {
        return time - time%resTime;
    }

    public MergedDbDumper(long minTimeStamp, long maxTimeStamp){
        m_minTimeStamp = normalizeTime(minTimeStamp,m_resTime);
        m_maxTimeStamp = normalizeTime(maxTimeStamp,m_resTime);
        m_refTime = getSamplesTime();
    }



    protected ArrayList<MergedStats> getTimeMapForProc(int pid)
    {
        ArrayList<MergedStats> ret = new  ArrayList<>();

        for(Long time: m_refTime)
        {
            ret.add(new MergedStats(pid, time));
        }

        return ret;
    }

    public void fillEmptyStats() {

        ArrayList<Pair<String,ArrayList<MergedStats>>> lStatsToInterp = new ArrayList<>();

        for (HashMap.Entry<Integer,ArrayList<MergedStats> > entry :
                m_mergedStatsByPid.entrySet()) {

            ArrayList<MergedStats> mergedStats = entry.getValue();

            //ScreenUsage
            retrieveStatsToInterpolate(ScreenUsageTable.TABLE_NAME,lStatsToInterp, mergedStats);

            //cpuUsage
            retrieveStatsToInterpolate(CpuUsageTable.TABLE_NAME,lStatsToInterp, mergedStats);

            //ramUsage
            retrieveStatsToInterpolate(RamUsageTable.TABLE_NAME,lStatsToInterp, mergedStats);

            //batteryUsage
            retrieveStatsToInterpolate(BatteryUsageTable.TABLE_NAME,lStatsToInterp, mergedStats);

            //sysCallsUsage
            retrieveStatsToInterpolate(SysCallsStatisticsTable.TABLE_NAME,lStatsToInterp, mergedStats);


        }

        for (int i=0; i<lStatsToInterp.size(); ++i)
        {
            interpolate(lStatsToInterp.get(i));
        }

    }

    protected void retrieveStatsToInterpolate(String tblName, ArrayList<Pair<String, ArrayList<MergedStats>>> lStatsToInterp,
                                              ArrayList<MergedStats> lmergedStats) {
        Pair<String,ArrayList<MergedStats>> statsToInterp = null;
        MergedStats prevStats = null;

        for (MergedStats mstats : lmergedStats) {

            if(statsToInterp != null)
            {
                statsToInterp.second.add(mstats);
                if(mstats.isStatValid(tblName))
                {
                    //we need only 2 valid points for linear interpolation
                    statsToInterp = null;
                }

            }
            else
            {
                if(!mstats.isStatValid(tblName))
                {
                    statsToInterp = new Pair<>(tblName,
                            new ArrayList<MergedStats>());

                    if(prevStats != null)
                        statsToInterp.second.add(prevStats);

                    statsToInterp.second.add(mstats);
                    lStatsToInterp.add(statsToInterp);
                }

            }

            prevStats = mstats;

        }
    }

    public void interpolate(Pair<String, ArrayList<MergedStats>> lStats){

        ArrayList<MergedStats> arrMergedStats = lStats.second;
        String tblName = lStats.first;

        if(arrMergedStats!= null && arrMergedStats.size() != 0)
        {
            MergedStats firstStat = arrMergedStats.get(0);
            MergedStats lastStat = arrMergedStats.get(arrMergedStats.size()-1);

            if (firstStat.isStatValid(tblName)) {

                if (lastStat.isStatValid(tblName))
                {

                    if(arrMergedStats.size() > 1
                            && !arrMergedStats.get(1).isStatValid(tblName)) {


                        switch (tblName) {
                            //with memory ()
                            case RamUsageTable.TABLE_NAME:
                            {
                                long xa = firstStat.m_timeStamp,
                                        xb = lastStat.m_timeStamp;

                                long ya = (Long)firstStat.getValue(tblName),
                                        yb = (Long)lastStat.getValue(tblName);



                                int limit = arrMergedStats.size()-1;
                                for (int i=1;i<limit;++i)
                                {
                                    MergedStats mstat = arrMergedStats.get(i);
                                    mstat.setValue(tblName,
                                            linearInterpolationLong(xa,xb,ya,yb,mstat.m_timeStamp));
                                }

                                break;
                            }
                            case CpuUsageTable.TABLE_NAME:
                            case BatteryUsageTable.TABLE_NAME: {

                                long xa = firstStat.m_timeStamp,
                                        xb = lastStat.m_timeStamp;

                                double ya = (Float) firstStat.getValue(tblName),
                                        yb = (Float) lastStat.getValue(tblName);

                                int limit = arrMergedStats.size() - 1;
                                for (int i = 1; i < limit; ++i) {
                                    MergedStats mstat = arrMergedStats.get(i);
                                    mstat.setValue(tblName,
                                            linearInterpolationDouble(xa, xb,
                                                    ya, yb,
                                                    mstat.m_timeStamp).floatValue());

                                }
                            }
                            break;

                            case SysCallsStatisticsTable.TABLE_NAME:
                            {
                                //maybe we don't need to interpolate
                               /* long xa = 0,
                                        xb = lastStat.m_timeStamp;

                                long ya = 0,
                                        yb = (Integer) lastStat.getValue(tblName);
                                */
                                int limit = arrMergedStats.size() - 1;
                                for (int i = 1; i < limit; ++i) {
                                    MergedStats mstat = arrMergedStats.get(i);
                                    /*mstat.setValue(tblName,
                                            linearInterpolationLong(xa, xb,
                                                    ya, yb,
                                                    mstat.m_timeStamp).intValue());*/
                                    mstat.setDefaultValue(tblName);


                                }
                            }
                            break;

                            case ScreenUsageTable.TABLE_NAME:
                            {
                                int limit = arrMergedStats.size() - 1;
                                for (int i = 1; i < limit; ++i) {
                                    MergedStats mstat = arrMergedStats.get(i);
                                    mstat.setValue(tblName,
                                            firstStat.getValue(tblName));

                                }
                            }
                            break;

                        }

                    }
                    else
                    {
                        L.e("Something is going wrong with this algorithm!!!");
                    }

                }
                else
                {
                    //at the end
                    int i=1;
                    int limit = arrMergedStats.size();
                    for (;i<limit; ++i)
                    {
                        arrMergedStats.get(i).setValue(tblName,
                                arrMergedStats.get(0).getValue(tblName));
                    }
                }
            }
            else
            {
                //at the beginning
                int i=0;
                arrMergedStats.get(i).setDefaultValue(tblName);
                int limit = arrMergedStats.size();

                if(lastStat.isStatValid(tblName))
                    limit = arrMergedStats.size()-1;

                for (;i<limit; ++i)
                {
                    arrMergedStats.get(i).setDefaultValue(tblName);
                }
            }

        }

    }

    public void makeStatsAverage()
    {
        makeStatsAverage(-1);
    }

    protected void makeStatsAverage(int pid)
    {
        for (HashMap.Entry<Integer,ArrayList<MergedStats> > entry :
                m_mergedStatsByPid.entrySet()) {

            if(pid < 0 || pid == entry.getKey()) {
                ArrayList<MergedStats> mergedStats = entry.getValue();

                for (MergedStats entry1 :
                        mergedStats) {
                    entry1.makeAverages();
                }
            }

        }
    }

    protected  Double linearInterpolationDouble(long xa, long xb, double ya, double yb, long x){

        return ya + (yb-ya)*(x-xa)/(xb-xa);
    }

    protected  Long linearInterpolationLong(long xa, long xb, long ya, long yb, long x){

        return ya + (yb-ya)*(x-xa)/(xb-xa);
    }


    public void saveToFile(OutputStream outputStream) throws IOException {

        mergeProcIndependentStats();

        try {
            String dataStr = "";
            for (HashMap.Entry<Integer,ArrayList<MergedStats>> entry :
                    m_mergedStatsByPid.entrySet()) {
                ArrayList<MergedStats> mergedStats = entry.getValue();
                for (MergedStats entry1 :
                        mergedStats) {
                    dataStr = entry1.toFileFormat() + "\n";
                    outputStream.write(dataStr.getBytes());
                }
            }
        }
        catch (IOException e)
        {
            throw new IOException(e);
        }

    }

    private void mergeProcIndependentStats() {

        makeStatsAverage(0);

        ArrayList<MergedStats> mStats = m_mergedStatsByPid.get(0); // get stats of process with pid 0

        if(mStats != null)
        {
            m_mergedStatsByPid.remove(0);
            for(int idx = 0; idx< mStats.size(); ++idx)
            {
                MergedStats stat = mStats.get(idx);
                for (HashMap.Entry<Integer,ArrayList<MergedStats> > entry :
                        m_mergedStatsByPid.entrySet()) {
                    //iteration by pid
                    ArrayList<MergedStats> mergedStats = entry.getValue();

                    MergedStats entry1 = mergedStats.get(idx); // get the correspondent merged stats
                    entry1.setValue(BatteryUsageTable.TABLE_NAME,stat.m_averageBattUsage);
                    entry1.setValue(ScreenUsageTable.TABLE_NAME,stat.m_averageScreenStat);
                }

            }

        }

    }

    public void add(StatisticsData stat){


        if(stat != null && stat.isValid()){
            int pid = stat.pid();
            ArrayList<MergedStats> mStats = m_mergedStatsByPid.get(pid);

            if(mStats == null)
            {
                mStats = getTimeMapForProc(pid);
                m_mergedStatsByPid.put(pid, mStats);
            }

            long time = normalizeTime(stat.m_timeStamp,m_resTime);
            if(time>= m_minTimeStamp && time <= m_maxTimeStamp )
            {
                int idx = ((Long)((time - m_minTimeStamp)/m_resTime)).intValue();
                if(idx >= 0) {
                    mStats.get(idx).add(stat);
                }
                else
                {
                    L.e("Negative index!");
                }
            }
            else
            {
                L.e("The normalized timeStamp [" + time + "] of time [" + stat.m_timeStamp +
                        "] is not included in the range [" + m_minTimeStamp+ " - " + m_maxTimeStamp+ "]");
            }


        }
    }



    public List<Long> getSamplesTime()
    {
        List<Long> retVal = new ArrayList<>();
        long timeStamp = m_minTimeStamp;
        while (timeStamp <= m_maxTimeStamp){
            retVal.add(timeStamp);
            timeStamp = timeStamp + m_resTime;
        }
        return retVal;
    }

    public static class MergedStats {
        public int m_pid;
        public long m_timeStamp = 0;
        public List<Float> m_lCpuUsage = new ArrayList<>();
        public List<Float> m_lBattUsage = new ArrayList<>();
        public List<Long> m_lRamUsage = new ArrayList<>();
        public List<Integer> m_lNumSysCalls = new ArrayList<>();
        public List<Integer> m_lScreenStat = new ArrayList<>();

        public float m_averageCpuUsage = -1;
        public float m_averageBattUsage = -1;
        public long m_averageRamUsage = -1;
        public int m_averageNumSysCalls = -1;
        public int m_averageScreenStat = -1;


        public MergedStats(int pid,long time)
        {
            m_pid = pid;
            m_timeStamp = time;
        }

        void add(StatisticsData stat)
        {
            switch (stat.m_tableName)
            {
                case CpuUsageTable.TABLE_NAME:
                {
                    m_lCpuUsage.add(stat.m_percentage);
                    break;
                }
                case BatteryUsageTable.TABLE_NAME:
                {
                    m_lBattUsage.add(stat.m_percentage);
                    break;
                }
                case RamUsageTable.TABLE_NAME:
                {
                    m_lRamUsage.add(stat.m_quantity);
                    break;
                }
                case SysCallsStatisticsTable.TABLE_NAME:
                {
                    m_lNumSysCalls.add(stat.m_numCallsPerSec);
                    break;
                }

                case ScreenUsageTable.TABLE_NAME:
                {
                    m_lScreenStat.add(stat.m_screenStat);
                    break;
                }
            }
        }

        void setValue(String tblName,Object val){

            switch (tblName)
            {
                case CpuUsageTable.TABLE_NAME:
                {
                    if(val instanceof Float)
                        m_averageCpuUsage = (Float)val;
                    else
                        setDefaultValue(tblName);

                    break;
                }
                case BatteryUsageTable.TABLE_NAME:
                {
                    if(val instanceof Float)
                        m_averageBattUsage = (Float)val;
                    else
                        setDefaultValue(tblName);

                    break;
                }
                case RamUsageTable.TABLE_NAME:
                {
                    if(val instanceof Long)
                        m_averageRamUsage = (Long)val;
                    else
                        setDefaultValue(tblName);


                    break;
                }
                case SysCallsStatisticsTable.TABLE_NAME:
                {
                    if(val instanceof Integer)
                        m_averageNumSysCalls = (Integer)val;
                    else
                        setDefaultValue(tblName);

                    break;
                }
                case ScreenUsageTable.TABLE_NAME:
                {
                    if(val instanceof Integer)
                        m_averageScreenStat = (Integer)val;
                    else
                        setDefaultValue(tblName);

                    break;
                }
            }
        }

        Object getValue(String tblName)
        {
            Object ret = new Integer(0);
            switch (tblName)
            {
                case CpuUsageTable.TABLE_NAME:
                {
                    ret = new Float(m_averageCpuUsage);
                    break;
                }
                case BatteryUsageTable.TABLE_NAME:
                {
                    ret = new Float(m_averageBattUsage);
                    break;
                }
                case RamUsageTable.TABLE_NAME:
                {
                    ret = new Long(m_averageRamUsage);
                    break;
                }
                case SysCallsStatisticsTable.TABLE_NAME:
                {
                    ret = new Integer(m_averageNumSysCalls);

                    break;
                }
                case ScreenUsageTable.TABLE_NAME:
                {
                    ret = new Integer(m_averageScreenStat);
                    break;
                }
            }

            return ret;
        }
        void setDefaultValue(String tblName){

            switch (tblName)
            {
                case CpuUsageTable.TABLE_NAME:
                {
                    m_averageCpuUsage = 0;
                    break;
                }
                case BatteryUsageTable.TABLE_NAME:
                {
                    m_averageBattUsage = 0;
                    break;
                }
                case RamUsageTable.TABLE_NAME:
                {
                    m_averageRamUsage = 0;
                    break;
                }
                case SysCallsStatisticsTable.TABLE_NAME:
                {
                    m_averageNumSysCalls = 0;
                    break;
                }
                case ScreenUsageTable.TABLE_NAME:
                {
                    m_averageScreenStat =0;
                    break;
                }
            }
        }

        boolean isStatValid(String tblName)
        {
            boolean ret = false;
            switch (tblName)
            {
                case CpuUsageTable.TABLE_NAME:
                {
                    ret = m_averageCpuUsage != -1;
                    break;
                }
                case BatteryUsageTable.TABLE_NAME:
                {
                    ret = m_averageBattUsage != -1;
                    break;
                }
                case RamUsageTable.TABLE_NAME:
                {
                    ret = m_averageRamUsage != -1;
                    break;
                }
                case SysCallsStatisticsTable.TABLE_NAME:
                {
                    ret = m_averageNumSysCalls != -1;
                    break;
                }
                case ScreenUsageTable.TABLE_NAME:
                {
                    ret = m_averageScreenStat != -1;
                    break;
                }
            }

            return  ret;
        }

        public String toFileFormat()
        {
            return m_timeStamp + BaseTable.FIELD_SEPARATOR
                    + m_pid + BaseTable.FIELD_SEPARATOR
                    + m_averageCpuUsage +BaseTable.FIELD_SEPARATOR
                    + m_averageRamUsage + BaseTable.FIELD_SEPARATOR
                    + m_averageBattUsage +  BaseTable.FIELD_SEPARATOR
                    + m_averageScreenStat +  BaseTable.FIELD_SEPARATOR
                    + m_averageNumSysCalls;
        }
        void makeAverages(){

            if(m_lCpuUsage.size() != 0) {
                m_averageCpuUsage = 0;
                for (float perc : m_lCpuUsage) {
                    m_averageCpuUsage += perc;
                }
                m_averageCpuUsage = m_averageCpuUsage / m_lCpuUsage.size();
            }

            if(m_lBattUsage.size() > 0) {
                m_averageBattUsage = 0;
                for (float perc : m_lBattUsage) {
                    m_averageBattUsage += perc;
                }
                m_averageBattUsage = m_averageBattUsage / m_lBattUsage.size();
            }

            if(m_lNumSysCalls.size() != 0) {
                m_averageNumSysCalls = 0;
                for (int numSys : m_lNumSysCalls) {
                    m_averageNumSysCalls += numSys;
                }
                m_averageNumSysCalls = m_averageNumSysCalls / m_lNumSysCalls.size();
            }

            if(m_lRamUsage.size() != 0) {
                m_averageRamUsage = 0;
                for (long quant : m_lRamUsage) {
                    m_averageRamUsage += quant;
                }
                m_averageRamUsage = m_averageRamUsage / m_lRamUsage.size();
            }

            if(m_lScreenStat.size() != 0) {
                m_averageScreenStat = 0;
                for (int quant : m_lScreenStat) {
                    m_averageScreenStat += quant;
                }
                m_averageScreenStat = m_averageScreenStat / m_lScreenStat.size();
            }
        }

    }
}