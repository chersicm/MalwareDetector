package alarilab.malwaredetector.utility.Test;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import alarilab.malwaredetector.database.tables.BatteryUsageTable;
import alarilab.malwaredetector.database.tables.CpuUsageTable;
import alarilab.malwaredetector.database.tables.RamUsageTable;
import alarilab.malwaredetector.database.tables.SysCallsTable;
import alarilab.malwaredetector.services.DbHandler;
import alarilab.malwaredetector.shared.StatisticsData;
import alarilab.malwaredetector.utility.logger.L;

/**
 * Created by vidal on 19.03.15.
 */
public class DbHandlerTester {
    public final static boolean DEBUG = false;
    private Timer m_timerTest = new Timer();

    public void start() {
        m_timerTest = new Timer(getClass().getName() + "_startTimerThread", false);
        m_timerTest.schedule(new TestTask(), 60000, 30000);
    }

    public void clear() {
        m_timerTest.cancel();
        m_timerTest.purge();
        m_timerTest = null;
    }

    private void testDestroyFunction() {
        DbHandler.getInstance().destroyDatabase();

        if (!DbHandler.getInstance().isTableExists(SysCallsTable.TABLE_NAME)) {
            L.i("Destroy functionality passed!");
        }
        else {
            L.i("Destroy functionality failed!");
        }
    }

    private void testSaveFunction() {
        List<StatisticsData> l_statsData = new ArrayList<>();
        StatisticsData stat1, stat2, stat3, stat4, stat5;
        stat1 = new StatisticsData(254);
        stat1.m_tableName = SysCallsTable.TABLE_NAME;
        stat1.m_sysCallStr = "OPEN_SYS_CALL0";
        stat1.m_timeStamp = (new Date()).getTime();

        stat2 = new StatisticsData(254);
        stat2.m_tableName = SysCallsTable.TABLE_NAME;
        stat2.m_sysCallStr = "OPEN_SYS_CALL1";
        stat2.m_timeStamp = (new Date()).getTime();

        /*stat2 = new StatisticsData(300);
        stat2.m_tableName = SysCallsStatisticsTable.TABLE_NAME;
        stat2.m_numCallsPerSec = 2;
        stat2.m_timeStamp = (new Date()).getTime();*/

        stat3 = new StatisticsData(301);
        stat3.m_tableName = CpuUsageTable.TABLE_NAME;
        stat3.m_percentage = 0.20f;
        stat3.m_timeStamp = (new Date()).getTime();

        stat4 = new StatisticsData(302);
        stat4.m_tableName = RamUsageTable.TABLE_NAME;
        stat4.m_quantity = 300;
        stat4.m_timeStamp = (new Date()).getTime();

        stat5 = new StatisticsData(305);
        stat5.m_tableName = BatteryUsageTable.TABLE_NAME;
        stat5.m_percentage = 0.1f;
        stat5.m_timeStamp = (new Date()).getTime();

        l_statsData.add(stat1);
        l_statsData.add(stat2);
        l_statsData.add(stat3);
        l_statsData.add(stat4);
        l_statsData.add(stat5);

        DbHandler.getInstance().saveData(l_statsData, true);

        try {
            Thread.sleep(30000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        int numRows = DbHandler.getInstance().getNumRows(BatteryUsageTable.TABLE_NAME);

        if (numRows > 0) {
            L.i("Save functionality passed!");
        }
        else {
            L.e("Save functionality failed!");
        }
    }

    private void testReadFunction() {
        L.i("\n\n*******Reading from db********\n");
        List<StatisticsData> lReadStats = DbHandler.getInstance().readTablesContents(false);
        boolean dump = false;
        for (StatisticsData data : lReadStats) {
            if (!dump) {
                L.i("Read functionality passed!");
                dump = true;
            }

            data.dump();
        }
        lReadStats.clear();
        L.i("*******Reading from db finished********");
        /*L.i("\n\n*******Reading from db and Delete after reading********\n");
        List<StatisticsData> lReadStats2 = DbHandler.getInstance().readTablesContents(true);
        for (StatisticsData data: lReadStats2)
        {
            data.dump();
        }
        lReadStats.clear();
        L.i("*******Reading from db and Delete after reading finished!********");*/
    }

    private void testDeleteFunction() {
        int numRows = DbHandler.getInstance().getNumRows(SysCallsTable.TABLE_NAME);

        if (numRows != 0) {
            DbHandler.getInstance().deleteContentsTable(SysCallsTable.TABLE_NAME);
            numRows = DbHandler.getInstance().getNumRows(SysCallsTable.TABLE_NAME);
            if (numRows == 0) {
                L.i("The delete functionality passed!");
            }
            else {
                L.e("The delete functionality failed!");

            }
        }
        else {
            L.w("The table is already empty!");
        }
    }


    private class TestTask extends TimerTask {
        @Override
        public void run() {

            L.i("\n*******Starting to test the save functionality******");
            testSaveFunction();

            L.i("\n*******Starting to test the read functionality******");
            testReadFunction();

            //L.i("\n*******Restarting to test the save functionality******");
            //    testSaveFunction();

            //L.i("******\nStarting to test the delete functionality*******");
            //    testDeleteFunction();

            //L.i("\n*******Starting to test the destroy functionality******");
            //testDestroyFunction();

        }
    }

}
